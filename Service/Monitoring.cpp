#pragma warning (disable : 4996)

#include <windows.h>
#include <stdio.h>
#include <vector>
#include <Shlwapi.h>
#include <string>
#include <queue>

HANDLE event_log2;
HANDLE mobitoringThread;

struct MonitoringParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
};

void PrintNotifyInfo(PFILE_NOTIFY_INFORMATION pNotify) {
	WCHAR szwFileName[MAX_PATH];
	ULONG ulCount = min(pNotify->FileNameLength / 2, MAX_PATH - 1);
	wcsncpy(szwFileName, pNotify->FileName, ulCount);
	szwFileName[ulCount] = L'\0';
	wprintf(L"%d. %s\n", pNotify->Action, szwFileName);

	const wchar_t* messages = szwFileName;
	ReportEvent(event_log2, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
}

DWORD WINAPI MonitoringThread(LPVOID lpvParam) {
	event_log2 = RegisterEventSource(NULL, L"MTUCI_Antimalware1Service");
	std::vector<const wchar_t*> path;
	//path = *(std::vector<const wchar_t*>*)lpvParam;
	std::queue<const wchar_t*>* toScan = (*(MonitoringParameters*)lpvParam).toScan;

	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueEvent");;
	HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueMutex");

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\monitoring.dat");

	FILE* fp;
	wchar_t* lptr;
	unsigned int len = 0;
	int nlines = 0;

	fp = _wfopen(szFile, L"rb");

	wchar_t letters[MAX_PATH];
	while ((fgetws(letters, MAX_PATH, fp)) != NULL) {
		len = wcslen(letters);
		letters[len - 1] = '\0';
		lptr = (wchar_t*)malloc(len * sizeof(wchar_t));
		wcscpy(lptr, letters);
		path.push_back(lptr);
	}



	fclose(fp);

	//wprintf(L"path size: %d\n", path.size());

	DWORD nBufferLength = 60 * 1024;
	HANDLE* hDir = new HANDLE[path.size()];
	OVERLAPPED* o = new OVERLAPPED[path.size()];
	HANDLE* hEvents = new HANDLE[path.size()];
	BYTE** lpBuffer = new BYTE * [path.size()];
	DWORD returnedBytes = 0;
	int count = 0;

	for (int i = 0; i < path.size(); i++) {
		HANDLE h = CreateFile(path[i],
			GENERIC_READ,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
			NULL
		);
		/*if (h == 0) {
			continue;
		}*/
		count++;
		hDir[i] = h;
		o[i].hEvent = CreateEvent(0, FALSE, FALSE, 0);
		hEvents[i] = o[i].hEvent;
		lpBuffer[i] = new BYTE[nBufferLength];

		ReadDirectoryChangesW(hDir[i], lpBuffer[i], nBufferLength, TRUE,
			FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME,
			&returnedBytes, &o[i], 0);
	}



	bool bStop = false;
	while (!bStop) {
		DWORD dwWaitStatus = WaitForMultipleObjects(count, hEvents, false, INFINITE);
		if (dwWaitStatus < count) {
			DWORD seek = 0;
			while (seek < nBufferLength) {
				PFILE_NOTIFY_INFORMATION pNotify = PFILE_NOTIFY_INFORMATION(lpBuffer[dwWaitStatus] + seek);
				seek += pNotify->NextEntryOffset;

				PrintNotifyInfo(pNotify);
				if (pNotify->Action == FILE_ACTION_ADDED || pNotify->Action == FILE_ACTION_MODIFIED || pNotify->Action == FILE_ACTION_RENAMED_NEW_NAME) {
					//const wchar_t* messages = L"MONITORED";
					//ReportEvent(event_log2, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
					WCHAR szwFileName[MAX_PATH];
					wcscpy(szwFileName, path[dwWaitStatus]);
					wcscat(szwFileName, L"\\");
					ULONG ulCount = min(pNotify->FileNameLength / 2, MAX_PATH - 1);
					wcsncat(szwFileName, pNotify->FileName, ulCount);
					//wcscat(szwFileName, L"000");
					//szwFileName[ulCount] = L'\0';
					const wchar_t* messages = szwFileName;
					ReportEvent(event_log2, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
					WaitForSingleObject(hMutex, INFINITE);
					(*toScan).push(szwFileName);
					SetEvent(hEvent);
					ReleaseMutex(hMutex);
				}

				if (pNotify->NextEntryOffset == 0)
					break;
			}
			ReadDirectoryChangesW(hDir[dwWaitStatus], lpBuffer[dwWaitStatus], nBufferLength, TRUE,
				FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME,
				&returnedBytes, &o[dwWaitStatus], 0);
		}
	}

	for (int i = 0; i < count; i++) {
		CloseHandle(hEvents[i]);
	}
	delete[] lpBuffer;
	return 0;
}

void startMonitoring(std::vector<const wchar_t*> path) {
	MonitoringThread(new std::vector<const wchar_t*>{ L"D:\\test1", L"D:\\test2" });
}