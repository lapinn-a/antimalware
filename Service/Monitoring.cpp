#pragma warning (disable : 4996)

#include <windows.h>
#include <stdio.h>

void PrintNotifyInfo(PFILE_NOTIFY_INFORMATION pNotify) {
	WCHAR szwFileName[MAX_PATH];
	ULONG ulCount = min(pNotify->FileNameLength / 2, MAX_PATH - 1);
	wcsncpy(szwFileName, pNotify->FileName, ulCount);
	szwFileName[ulCount] = L'\0';
	wprintf(L"%d. %s\n", pNotify->Action, szwFileName);

	const wchar_t* messages = szwFileName;
	ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
}

int main(int argc, TCHAR * argv[]) {
	event_log1 = RegisterEventSource(NULL, L"MTUCI_Antimalware1Service");
	LPCTSTR lpszRootFolder = L"F:\\signatures";

	HANDLE hDir = CreateFile(lpszRootFolder,
		GENERIC_READ,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OVERLAPPED,
		NULL
	);


	OVERLAPPED o = {};

	o.hEvent = CreateEvent(0, FALSE, FALSE, 0);

	DWORD nBufferLength = 60 * 1024;
	BYTE* lpBuffer = new BYTE[nBufferLength];
	bool bStop = false;
	while (!bStop) {
		DWORD returnedBytes = 0;
		ReadDirectoryChangesW(hDir, lpBuffer, nBufferLength, TRUE,
			FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME,
			&returnedBytes, &o, 0);

		DWORD dwWaitStatus = WaitForSingleObject(o.hEvent, INFINITE);
		switch (dwWaitStatus) {
		case WAIT_OBJECT_0:
		{
			DWORD seek = 0;
			while (seek < nBufferLength) {
				PFILE_NOTIFY_INFORMATION pNotify = PFILE_NOTIFY_INFORMATION(lpBuffer + seek);
				seek += pNotify->NextEntryOffset;

				PrintNotifyInfo(pNotify);

				if (pNotify->NextEntryOffset == 0)
					break;
			}

		}
		break;
		default:
			bStop = true;
			break;
		}
	}

	CloseHandle(o.hEvent);
	delete[] lpBuffer;
	return 0;
}