#pragma warning (disable : 4996)
#pragma once

#include <windows.h>
#include <string>
#include <unordered_map>
#include <openssl/ssl.h>

#include <iostream>
#include <iomanip>
#include <strsafe.h>
#include <tchar.h>
#include <map>
#pragma comment(lib, "Shlwapi.lib")


#define SIGNATURE_BASE "D:\\base.amb"

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

std::unordered_multimap<uint64_t, Signature> parseBase() {
	uint64_t prefix;
	Signature signature;
	char nameLength;
	char nameBuffer[255];

	std::unordered_multimap<uint64_t, Signature> signatures;

	FILE* file = fopen(SIGNATURE_BASE, "rb");

	if (fread(&nameBuffer, 1, 16, file) == 16) {
		if (strncmp(nameBuffer, "LapinAntimalware", 16) != 0) {
			fclose(file);
			return signatures;
		}
	}

	while (fread(&nameLength, 1, 1, file) == 1) {
		fread(&nameBuffer, 1, nameLength, file); // чтение имени
		fread(&prefix, 8, 1, file); // чтение восьми первых байтов сигнатуры
		fread(&signature, 49, 1, file); // чтение полей структуры

		signature.name = std::string(nameBuffer, nameLength);
		signatures.insert(std::pair<uint64_t, Signature>(prefix, signature));
	}
	fclose(file);
	return signatures;
}

ScanResult scanFile(const wchar_t* fileName, byte* buffer, size_t bufferSize, byte* sigBuffer, std::unordered_multimap<uint64_t, Signature>* signatures) {
	SHA256_CTX sha256;
	uint64_t prefix;
	uint64_t pos = 0;
	SHFILEINFO fileInformation = { 0 };
	size_t charCount;

	FILE* file = _wfopen(fileName, L"rb");
	DWORD_PTR exeInfo = SHGetFileInfo(fileName, 0, &fileInformation, sizeof(fileInformation), SHGFI_EXETYPE);

	if (!file || exeInfo == 0) {
		fclose(file);
		return ScanResult{ std::wstring(fileName), false, "Not a virus" };
	}

	do {
		charCount = fread(buffer, 1, bufferSize, file);
		if (charCount < 8) {
			break;
		}
		pos += charCount;

		for (size_t i = 0; i < charCount - 7; i++) {
			prefix = *(uint64_t*)(buffer + i);
			auto its = (*signatures).equal_range(prefix);
			for (auto it = its.first; it != its.second; ++it) {
				if (pos - charCount + i < it->second.begin || pos - charCount + i > it->second.end) {
					continue; // сигнатура вне интервала
				}
				if (charCount < bufferSize && i + it->second.length > charCount) {
					continue; // конец сигнатуры будет после конца файла
				}
				unsigned char hash[SHA256_DIGEST_LENGTH];
				SHA256_Init(&sha256);
				if (i + it->second.length <= charCount) {
					// вся сигнатура уже в буфере
					SHA256_Update(&sha256, buffer + i, it->second.length);
				} else {
					// прочитать сигнатуру в буфер
					fseek(file, -(int)(bufferSize - i), SEEK_CUR);
					fread(&sigBuffer, 1, it->second.length, file);
					fseek(file, pos, SEEK_SET);
					SHA256_Update(&sha256, sigBuffer, it->second.length);
				}
				SHA256_Final(hash, &sha256);
				if (memcmp(hash, it->second.SHA256, 1) != 0) {
					continue; // хеш не совпал
				}
				fclose(file);
				return ScanResult{ std::wstring(fileName), true, it->second.name };
			}
		}
	} while (charCount == bufferSize);
	fclose(file);
	return ScanResult{ std::wstring(fileName), false, "Not a virus" };
}

std::vector<ScanResult> scanDirectory(const wchar_t* path, byte * buffer, size_t bufferSize, byte * sigBuffer, std::unordered_multimap<uint64_t, Signature> * signatures) {
	wchar_t temp[MAX_PATH] = { L'\0' };
	wsprintf(temp, L"%s\\*.*", path);
	std::vector<ScanResult> result;

	WIN32_FIND_DATA fd;
	HANDLE handle = FindFirstFile(temp, &fd);
	if (handle != INVALID_HANDLE_VALUE) {
		do {
			if (wcscmp(L".", fd.cFileName) != 0 && wcscmp(L"..", fd.cFileName) != 0) {
				if (fd.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) {
					wchar_t res[MAX_PATH] = { L'\0' };
					wsprintf(res, L"%s\\%s", path, fd.cFileName);
					std::vector<ScanResult> recursiveResult = scanDirectory(res, buffer, bufferSize, sigBuffer, signatures);
					result.insert(result.end(), recursiveResult.begin(), recursiveResult.end());
				} else {
					int len = wcslen(path) + wcslen(fd.cFileName) + 2;
					wchar_t* file = new wchar_t[wcslen(path) + wcslen(fd.cFileName) + 2];
					wcscpy(file, path);
					wcscat(file, L"\\");
					wcscat(file, fd.cFileName);
					//ScanResult res = scanFile(file, buffer, bufferSize, sigBuffer, signatures);
					result.push_back(scanFile(file, buffer, bufferSize, sigBuffer, signatures));
					delete[] file;
				}
			}
		} while (FindNextFile(handle, &fd));
	}
	FindClose(handle);
	return result;
}

std::vector<ScanResult> scan(std::vector<const wchar_t*> path, size_t bufferSize, std::unordered_multimap<uint64_t, Signature> * signatures) {
	byte* buffer = new byte[bufferSize];
	byte* sigBuffer = new byte[255];
	std::vector<ScanResult> result;
	for (unsigned int i = 0; i < path.size(); i++) {
		DWORD attr = GetFileAttributes(path[i]);
		if (attr & FILE_ATTRIBUTE_DIRECTORY) {
			std::vector<ScanResult> recursiveResult = scanDirectory(path[i], buffer, bufferSize, sigBuffer, signatures);
			result.insert(result.end(), recursiveResult.begin(), recursiveResult.end());
		} else {
			result.push_back(scanFile(path[i], buffer, bufferSize, sigBuffer, signatures));
		}
	}
	delete[] buffer;
	delete[] sigBuffer;
	return result;
}
