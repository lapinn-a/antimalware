#pragma warning (disable : 4996)
#pragma once

#include <windows.h>
#include <string>
#include <unordered_map>
#include <openssl/ssl.h>

#include <iostream>
#include <iomanip>
#include <strsafe.h>
#include <tchar.h>
#include <map>
#include <queue>
#pragma comment(lib, "Shlwapi.lib")

HANDLE event_log1;

#define SIGNATURE_BASE "D:\\base.amb"

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

struct ScannerParameters {
	bool* flagStop;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

std::queue<ScanResult>* res;

HANDLE hQueueEvent1;
HANDLE hQueueMutex1;

HANDLE hResultsEvent1;
HANDLE hResultsMutex1;

bool* flagStop1;

std::unordered_multimap<uint64_t, Signature> parseBase() {
	uint64_t prefix;
	Signature signature;
	char nameLength;
	char nameBuffer[255];

	std::unordered_multimap<uint64_t, Signature> signatures;

	FILE* file = fopen(SIGNATURE_BASE, "rb");

	if (fread(&nameBuffer, 1, 16, file) == 16) {
		if (strncmp(nameBuffer, "LapinAntimalware", 16) != 0) {
			fclose(file);
			return signatures;
		}
	}

	while (fread(&nameLength, 1, 1, file) == 1) {
		fread(&nameBuffer, 1, nameLength, file); // чтение имени
		fread(&prefix, 8, 1, file); // чтение восьми первых байтов сигнатуры
		fread(&signature, 49, 1, file); // чтение полей структуры

		signature.name = std::string(nameBuffer, nameLength);
		signatures.insert(std::pair<uint64_t, Signature>(prefix, signature));
	}
	fclose(file);
	return signatures;
}

void write(ScanResult res, std::queue<ScanResult>* results) {

	if (res.isMalware) {
		WaitForSingleObject(hResultsMutex1, INFINITE);
		(*results).push(res);

		//const wchar_t* messages = L"SETTING EVENT FOR WRITE";
		//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

		if (SetEvent(hResultsEvent1) == 0) {
			//messages = L"SET EVENT ERROR";
			//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
			DWORD error = GetLastError();

		}
		ReleaseMutex(hResultsMutex1);
	}

}

int scanFile(const wchar_t* fileName, byte* buf, size_t bufSize, byte* sigBuf, std::unordered_multimap<uint64_t, Signature>* signatures, std::queue<ScanResult>* res) {
	SHA256_CTX sha256;
	uint64_t prefix;
	uint64_t pos = 0;
	SHFILEINFO fileInformation = { 0 };
	size_t charCount;

	DWORD_PTR exeInfo = SHGetFileInfo(fileName, 0, &fileInformation, sizeof(fileInformation), SHGFI_EXETYPE);
	if (exeInfo == 0) {
		write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
		return 0;
	}

	FILE* file = _wfopen(fileName, L"rb");
	if (!file) {
		write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
		return 0;
	}

	ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &fileName, NULL);

	do {
		charCount = fread(buf, 1, bufSize, file);
		if (charCount < 8) {
			break;
		}
		pos += charCount;

		for (size_t i = 0; i < charCount - 7; i++) {
			prefix = *(uint64_t*)(buf + i);
			auto its = (*signatures).equal_range(prefix);
			for (auto it = its.first; it != its.second; ++it) {
				if (pos - charCount + i < it->second.begin || pos - charCount + i > it->second.end) {
					continue; // сигнатура вне интервала
				}
				if (charCount < bufSize && i + it->second.length > charCount) {
					continue; // конец сигнатуры будет после конца файла
				}
				unsigned char hash[SHA256_DIGEST_LENGTH];
				SHA256_Init(&sha256);
				if (i + it->second.length <= charCount) {
					// вся сигнатура уже в буфере
					SHA256_Update(&sha256, buf + i, it->second.length);
				} else {
					// прочитать сигнатуру в буфер
					fseek(file, -(int)(bufSize - i), SEEK_CUR);
					fread(&sigBuf, 1, it->second.length, file);
					fseek(file, pos, SEEK_SET);
					SHA256_Update(&sha256, sigBuf, it->second.length);
				}
				SHA256_Final(hash, &sha256);
				if (memcmp(hash, it->second.SHA256, 1) != 0) {
					continue; // хеш не совпал
				}
				fclose(file);
				write(ScanResult{ std::wstring(fileName), true, it->second.name }, res);
				return 0;
			}
		}
	} while (charCount == bufSize);
	fclose(file);
	write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
	return 0;
}

int scanDirectory(const wchar_t* path, byte * buf, size_t bufSize, byte * sigBuf, std::unordered_multimap<uint64_t, Signature> * signatures, std::queue<ScanResult>* res) {
	wchar_t temp[MAX_PATH] = { L'\0' };
	wsprintf(temp, L"%s\\*.*", path);
	WIN32_FIND_DATA fd;
	HANDLE handle = FindFirstFile(temp, &fd);

	if (handle != INVALID_HANDLE_VALUE) {
		do {
			if (*flagStop1) {
				//const wchar_t* messages = L"EXIT BY STOP FLAG";
				//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
				return 0;
			}

			if (wcscmp(L".", fd.cFileName) != 0 && wcscmp(L"..", fd.cFileName) != 0) {
				if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && wcscmp(L"$Recycle.Bin", fd.cFileName) != 0 && wcscmp(L"$RECYCLE.BIN", fd.cFileName) != 0) {
					if ((fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)) {
						continue;
					}

					wchar_t resPath[MAX_PATH] = { L'\0' };
					wsprintf(resPath, L"%s\\%s", path, fd.cFileName);
					scanDirectory(resPath, buf, bufSize, sigBuf, signatures, res);

					if (*flagStop1) {
						//const wchar_t* messages = L"EXIT BY STOP FLAG";
						//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
						return 0;
					}
				} else {
					int len = wcslen(path) + wcslen(fd.cFileName) + 2;
					wchar_t* file = new wchar_t[wcslen(path) + wcslen(fd.cFileName) + 2];
					wcscpy(file, path);
					wcscat(file, L"\\");
					wcscat(file, fd.cFileName);
					scanFile(file, buf, bufSize, sigBuf, signatures, res);
					delete[] file;
				}
			}
		} while (FindNextFile(handle, &fd));
	}
	FindClose(handle);
	return 0/*result*/;
}

DWORD WINAPI ScannerThread(LPVOID lpvParam) {
	/*/*//*/*/event_log1 = RegisterEventSource(NULL, L"MTUCI_AntimalwareService");
	int bufferSize = 104857600; // 100 МБ
	byte* buffer = new byte[bufferSize];
	byte* sigBuffer = new byte[255];
	hQueueEvent1 = OpenEvent(EVENT_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueEvent");
	hQueueMutex1 = OpenMutex(MUTEX_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueMutex");
	hResultsEvent1 = OpenEvent(EVENT_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_ResultsEvent");
	hResultsMutex1 = OpenMutex(MUTEX_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_ResultsMutex");

	std::queue<const wchar_t*>* paths = (*(ScannerParameters*)lpvParam).toScan;

	res = (*(ScannerParameters*)lpvParam).scanResults;
	flagStop1 = (*(ScannerParameters*)lpvParam).flagStop;

	std::unordered_multimap<uint64_t, Signature> base = parseBase();

	const wchar_t* path;

	while (true) {

		WaitForSingleObject(hQueueEvent1, INFINITE);
		WaitForSingleObject(hQueueMutex1, INFINITE);

		if ((*paths).size() > 0) {
			path = (*paths).front();
			(*paths).pop();
		} else {
			ResetEvent(hQueueEvent1);
			Sleep(1000);
			continue;
		}

		const wchar_t* message = std::wstring(L"THE PATH IS: ").append(path).c_str();
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		if ((*paths).size() == 0) {
			ResetEvent(hQueueEvent1);
		}

		ReleaseMutex(hQueueMutex1);

		DWORD attr = GetFileAttributes(path);
		if (attr & FILE_ATTRIBUTE_DIRECTORY) {
			scanDirectory(path, buffer, bufferSize, sigBuffer, &base, res);		
		} else {
			scanFile(path, buffer, bufferSize, sigBuffer, &base, res);
		}
	}
	delete[] buffer;
	delete[] sigBuffer;
	return 0;
}
