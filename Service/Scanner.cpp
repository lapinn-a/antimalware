#pragma warning (disable : 4996)
#pragma once

#include <windows.h>
#include <string>
#include <unordered_map>
#include <openssl/ssl.h>

#include <iostream>
#include <iomanip>
#include <strsafe.h>
#include <tchar.h>
#include <map>
#include <queue>
#pragma comment(lib, "Shlwapi.lib")

HANDLE event_log1;

#define SIGNATURE_BASE "D:\\base.amb"

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

struct ScannerParameters {
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

std::queue<ScanResult>* res;

HANDLE hQueueEvent1;
HANDLE hQueueMutex1;

HANDLE hResultsEvent1;
HANDLE hResultsMutex1;

std::unordered_multimap<uint64_t, Signature> parseBase() {
	uint64_t prefix;
	Signature signature;
	char nameLength;
	char nameBuffer[255];

	std::unordered_multimap<uint64_t, Signature> signatures;

	FILE* file = fopen(SIGNATURE_BASE, "rb");

	if (fread(&nameBuffer, 1, 16, file) == 16) {
		if (strncmp(nameBuffer, "LapinAntimalware", 16) != 0) {
			fclose(file);
			return signatures;
		}
	}

	while (fread(&nameLength, 1, 1, file) == 1) {
		fread(&nameBuffer, 1, nameLength, file); // чтение имени
		fread(&prefix, 8, 1, file); // чтение восьми первых байтов сигнатуры
		fread(&signature, 49, 1, file); // чтение полей структуры

		signature.name = std::string(nameBuffer, nameLength);
		signatures.insert(std::pair<uint64_t, Signature>(prefix, signature));
	}
	fclose(file);
	return signatures;
}

void write(ScanResult res, std::queue<ScanResult>* results) {
	WaitForSingleObject(hResultsMutex1, INFINITE);

	(*results).push(res);
	SetEvent(hResultsEvent1);

	const wchar_t* messages = res.file.c_str();
    ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

	ReleaseMutex(hResultsMutex1);
}

/*ScanResult*/int scanFile(const wchar_t* fileName, byte* buf, size_t bufSize, byte* sigBuf, std::unordered_multimap<uint64_t, Signature>* signatures, std::queue<ScanResult>* res) {
	SHA256_CTX sha256;
	uint64_t prefix;
	uint64_t pos = 0;
	SHFILEINFO fileInformation = { 0 };
	size_t charCount;

	//const wchar_t* messages = L"here3!!!";

	DWORD_PTR exeInfo = SHGetFileInfo(fileName, 0, &fileInformation, sizeof(fileInformation), SHGFI_EXETYPE);
	if (exeInfo == 0) {
		write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
		return 0/*ScanResult{ std::wstring(fileName), false, "Not a virus" }*/;
	}

	FILE* file = _wfopen(fileName, L"rb");
	if (!file) {
		write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
		return 0/*ScanResult{ std::wstring(fileName), false, "Not a virus" }*/;
	}

	ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &fileName, NULL);

	do {
		charCount = fread(buf, 1, bufSize, file);
		if (charCount < 8) {
			break;
		}
		pos += charCount;

		for (size_t i = 0; i < charCount - 7; i++) {
			prefix = *(uint64_t*)(buf + i);
			auto its = (*signatures).equal_range(prefix);
			for (auto it = its.first; it != its.second; ++it) {
				if (pos - charCount + i < it->second.begin || pos - charCount + i > it->second.end) {
					continue; // сигнатура вне интервала
				}
				if (charCount < bufSize && i + it->second.length > charCount) {
					continue; // конец сигнатуры будет после конца файла
				}
				unsigned char hash[SHA256_DIGEST_LENGTH];
				SHA256_Init(&sha256);
				if (i + it->second.length <= charCount) {
					// вся сигнатура уже в буфере
					SHA256_Update(&sha256, buf + i, it->second.length);
				} else {
					// прочитать сигнатуру в буфер
					fseek(file, -(int)(bufSize - i), SEEK_CUR);
					fread(&sigBuf, 1, it->second.length, file);
					fseek(file, pos, SEEK_SET);
					SHA256_Update(&sha256, sigBuf, it->second.length);
				}
				SHA256_Final(hash, &sha256);
				if (memcmp(hash, it->second.SHA256, 1) != 0) {
					continue; // хеш не совпал
				}
				fclose(file);
				write(ScanResult{ std::wstring(fileName), true, it->second.name }, res);
				return 0;
			}
		}
	} while (charCount == bufSize);
	fclose(file);
	write(ScanResult{ std::wstring(fileName), false, "Not a virus" }, res);
	return 0/*ScanResult{ std::wstring(fileName), false, "Not a virus" }*/;
}

/*std::vector<ScanResult>*/int scanDirectory(const wchar_t* path, byte * buf, size_t bufSize, byte * sigBuf, std::unordered_multimap<uint64_t, Signature> * signatures, std::queue<ScanResult>* res) {
	wchar_t temp[MAX_PATH] = { L'\0' };
	wsprintf(temp, L"%s\\*.*", path);
	//std::vector<ScanResult> result;

	WIN32_FIND_DATA fd;
	HANDLE handle = FindFirstFile(temp, &fd);
	if (handle != INVALID_HANDLE_VALUE) {
		do {
			if (wcscmp(L".", fd.cFileName) != 0 && wcscmp(L"..", fd.cFileName) != 0) {
				if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

					if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
						continue;
					}

					//const wchar_t* messages = L"here01!!!";
					//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

					wchar_t resPath[MAX_PATH] = { L'\0' };
					wsprintf(resPath, L"%s\\%s", path, fd.cFileName);
					/*std::vector<ScanResult> recursiveResult = */scanDirectory(resPath, buf, bufSize, sigBuf, signatures, res);
					//result.insert(result.end(), recursiveResult.begin(), recursiveResult.end());
				} else {

					//const wchar_t* messages = L"here02!!!";
					//ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

					int len = wcslen(path) + wcslen(fd.cFileName) + 2;
					wchar_t* file = new wchar_t[wcslen(path) + wcslen(fd.cFileName) + 2];
					wcscpy(file, path);
					wcscat(file, L"\\");
					wcscat(file, fd.cFileName);
					//ScanResult res = scanFile(file, buffer, bufferSize, sigBuffer, signatures);
					/*result.push_back(*/scanFile(file, buf, bufSize, sigBuf, signatures, res)/*)*/;
					delete[] file;
				}
			}
		} while (FindNextFile(handle, &fd));
	}
	FindClose(handle);
	return 0/*result*/;
}

DWORD WINAPI ScannerThread(LPVOID lpvParam) {
	/*/*//*/*/event_log1 = RegisterEventSource(NULL, L"MTUCI_AntimalwareService");
	int bufferSize = 104857600; // 100 МБ
	byte* buffer = new byte[bufferSize];
	byte* sigBuffer = new byte[255];
	hQueueEvent1 = OpenEvent(EVENT_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueEvent");
	hQueueMutex1 = OpenMutex(MUTEX_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueMutex");

	if (hQueueEvent1 == NULL) {
		const wchar_t* message = L"EVENT FAIL!!!!!";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		return 0;
	}

	std::queue<const wchar_t*>* paths = (*(ScannerParameters*)lpvParam).toScan;

	res = (*(ScannerParameters*)lpvParam).scanResults;

	std::unordered_multimap<uint64_t, Signature> base = parseBase();

	const wchar_t* path;

	while (true) {

		const wchar_t* message = L"11111go wait event";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		ResetEvent(hQueueEvent1);
		
		DWORD ttttt = WaitForSingleObject(hQueueEvent1, INFINITE);
		
		if (ttttt == WAIT_ABANDONED) {
			message = L"WAIT_ABANDONED";
			ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		if (ttttt == WAIT_OBJECT_0) {
			message = L"WAIT_OBJECT_0";
			ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		if (ttttt == WAIT_TIMEOUT) {
			message = L"WAIT_TIMEOUT";
			ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		if (ttttt == WAIT_FAILED) {
			message = std::wstring(L"WAIT_FAILED ").append(std::to_wstring(GetLastError())).c_str();
			ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		message = L"11111go wait mutex";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hQueueMutex1, INFINITE);

		message = L"11111get path";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		if ((*paths).size() > 0) {
			path = (*paths).front();
			(*paths).pop();
		} else {
			ResetEvent(hQueueEvent1);
			Sleep(1000);
			continue;
		}

		message = L"11111got path";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		if ((*paths).size() == 0) {
			message = L"11111go reset event";
			ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			ResetEvent(hQueueEvent1);
		}
		message = L"11111go release mutex";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		ReleaseMutex(hQueueMutex1);

		message = L"11111released mutex";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		const wchar_t* messages = L"SCAN!!!";
		ReportEvent(event_log1, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &(path), NULL);

		DWORD attr = GetFileAttributes(path);
		if (attr & FILE_ATTRIBUTE_DIRECTORY) {
			/*std::vector<ScanResult> recursiveResult = */scanDirectory(path, buffer, bufferSize, sigBuffer, &base, res);
			//result.insert(result.end(), recursiveResult.begin(), recursiveResult.end());
		} else {
			/*res.push_back(*/scanFile(path, buffer, bufferSize, sigBuffer, &base, res)/*)*/;
		}
	}
	delete[] buffer;
	delete[] sigBuffer;
	return 0/*result*/;
}
