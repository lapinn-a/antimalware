#pragma warning (disable : 4996)

#include <windows.h>
#include <stdio.h>
#include <vector>
#include <Shlwapi.h>
#include <string>
#include <queue>
#include <time.h>

HANDLE event_log3;

struct ScheduleParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
};

DWORD WINAPI ScheduleThread(LPVOID lpvParam) {
	event_log3 = RegisterEventSource(NULL, L"MTUCI_Antimalware1Service");
	std::vector<const wchar_t*> path;
	//path = *(std::vector<const wchar_t*>*)lpvParam;
	std::queue<const wchar_t*>* toScan = (*(ScheduleParameters*)lpvParam).toScan;

	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueEvent");
	HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, NULL, L"MTUCI_AntimalwareService_QueueMutex");

	TCHAR szFile[MAX_PATH];
	FILE* fp;

	while (true) {

		GetModuleFileName(NULL, szFile, MAX_PATH);
		PathRemoveFileSpec(szFile);
		wcscat(szFile, L"\\schedule.dat");

		fp = _wfopen(szFile, L"r+b");
		char16_t monthBits;
		*(char*)&monthBits = fgetc(fp);
		*((char*)&monthBits + 1) = fgetc(fp);

		char32_t dayBits;
		*(char*)&dayBits = fgetc(fp);
		*((char*)&dayBits + 1) = fgetc(fp);
		*((char*)&dayBits + 2) = fgetc(fp);
		*((char*)&dayBits + 3) = fgetc(fp);

		char32_t hourBits;
		*(char*)&hourBits = fgetc(fp);
		*((char*)&hourBits + 1) = fgetc(fp);
		*((char*)&hourBits + 2) = fgetc(fp);
		*((char*)&hourBits + 3) = fgetc(fp);

		char32_t minute = fgetc(fp);
		fclose(fp);

		time_t t = time(0);   // get time now
		tm* now = localtime(&t);
		//std::cout << now->tm_mon + 1 << " " << now->tm_mday << " " << now->tm_hour << " " << now->tm_min << "\n\n";

		if (!(((monthBits >> now->tm_mon) & 1) && ((dayBits >> (now->tm_mday - 1)) & 1) && ((hourBits >> (now->tm_hour)) & 1) && (now->tm_min == minute))) {
			const wchar_t* messages = L"wait 50s";
			ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

			if (!((monthBits >> now->tm_mon) & 1)) {
				messages = L"failed at month";
				ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
			}

			if (!((dayBits >> (now->tm_mday - 1)) & 1)) {
				messages = L"failed at day";
				ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
			}

			if (!((hourBits >> (now->tm_hour)) & 1)) {
				messages = L"failed at hour";
				ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
			}

			if (!(now->tm_min == minute)) {
				messages = L"failed at minute";
				ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
			}

			Sleep(50000);
			continue;
		}

		const wchar_t* messages = L"start sch";
		ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

		GetModuleFileName(NULL, szFile, MAX_PATH);
		PathRemoveFileSpec(szFile);
		wcscat(szFile, L"\\schedulePaths.dat");

		wchar_t* lptr;
		unsigned int len = 0;
		int nlines = 0;

		fp = _wfopen(szFile, L"rb");

		wchar_t letters[MAX_PATH];
		while ((fgetws(letters, MAX_PATH, fp)) != NULL) {
			len = wcslen(letters);
			letters[len - 1] = '\0';
			lptr = (wchar_t*)malloc(len * sizeof(wchar_t));
			wcscpy(lptr, letters);
			WaitForSingleObject(hMutex, INFINITE);
			(*toScan).push(lptr);
			SetEvent(hEvent);
			ReleaseMutex(hMutex);
		}

		fclose(fp);
		messages = L"wait 60s";
		ReportEvent(event_log3, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
		Sleep(60000);
	}

	return 0;
}