#pragma warning (disable : 4996)

#define WIN32_LEAN_AND_MEAN
#define DEFAULT_BUFLEN 512
// Файлы заголовков Windows
#include <windows.h>
#include <string>

#pragma comment(lib, "Ws2_32.lib")

#define SVCNAME TEXT("MTUCI_AntimalwareService")

SERVICE_STATUS          gSvcStatus;
SERVICE_STATUS_HANDLE   gSvcStatusHandle;
HANDLE                  ghSvcStopEvent = NULL;
HANDLE                  pipe;

// Глобальные переменные:
HINSTANCE hInst; // текущий экземпляр

DWORD WINAPI clientThread(LPVOID lpParam) {
	return 0;
}

//
// Purpose: 
//   Sets the current service status and reports it to the SCM.
//
// Parameters:
//   dwCurrentState - The current state (see SERVICE_STATUS)
//   dwWin32ExitCode - The system error code
//   dwWaitHint - Estimated time for pending operation, 
//     in milliseconds
// 
// Return value:
//   None
//
VOID ReportSvcStatus(DWORD dwCurrentState,
	DWORD dwWin32ExitCode,
	DWORD dwWaitHint) {
	static DWORD dwCheckPoint = 1;

	// Fill in the SERVICE_STATUS structure.

	gSvcStatus.dwCurrentState = dwCurrentState;
	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
	gSvcStatus.dwWaitHint = dwWaitHint;

	if (dwCurrentState == SERVICE_START_PENDING)
		gSvcStatus.dwControlsAccepted = 0;
	else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

	if ((dwCurrentState == SERVICE_RUNNING) ||
		(dwCurrentState == SERVICE_STOPPED))
		gSvcStatus.dwCheckPoint = 0;
	else gSvcStatus.dwCheckPoint = dwCheckPoint++;

	// Report the status of the service to the SCM.
	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

//
// Purpose: 
//   The service code
//
// Parameters:
//   dwArgc - Number of arguments in the lpszArgv array
//   lpszArgv - Array of strings. The first string is the name of
//     the service and subsequent strings are passed by the process
//     that called the StartService function to start the service.
// 
// Return value:
//   None
//
VOID SvcInit(DWORD dwArgc, LPTSTR* lpszArgv) {
	// TO_DO: Declare and set any required variables.
	//   Be sure to periodically call ReportSvcStatus() with 
	//   SERVICE_START_PENDING. If initialization fails, call
	//   ReportSvcStatus with SERVICE_STOPPED.

	// Create an event. The control handler function, SvcCtrlHandler,
	// signals this event when it receives the stop control code.

	ghSvcStopEvent = CreateEvent(
		NULL,    // default security attributes
		TRUE,    // manual reset event
		FALSE,   // not signaled
		NULL);   // no name

	if (ghSvcStopEvent == NULL) {
		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}

	// Report running status when initialization is complete.

	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

	// TO_DO: Perform work until service stops.

	while (1) {
		// Check whether to stop the service.

		WaitForSingleObject(ghSvcStopEvent, INFINITE);

		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}
}

//
// Purpose: 
//   Called by SCM whenever a control code is sent to the service
//   using the ControlService function.
//
// Parameters:
//   dwCtrl - control code
// 
// Return value:
//   None
//
VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
	// Handle the requested control code. 

	switch (dwCtrl) {
	case SERVICE_CONTROL_STOP:
		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

		// Signal the service to stop.

		SetEvent(ghSvcStopEvent);
		ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);

		return;

	case SERVICE_CONTROL_INTERROGATE:
		break;

	default:
		break;
	}

}

bool installService() {
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (!hSCManager) {
		DWORD e = GetLastError();
		if (e == ERROR_ACCESS_DENIED) {
			MessageBoxA(NULL, "access denied", "Error", 0);
		} else {
			MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error opening manager", 0);
		}
		return -1;
	}

	TCHAR szFileName[MAX_PATH];
	GetModuleFileName(NULL, szFileName, MAX_PATH);

	SC_HANDLE hService = CreateServiceW(
		hSCManager,
		L"MTUCI_AntimalwareService",
		L"MTUCI_AntimalwareService",
		SERVICE_ALL_ACCESS,
		SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START,
		SERVICE_ERROR_NORMAL,
		szFileName,
		NULL, NULL, NULL, NULL, NULL
	);

	if (!hService) {
		CloseServiceHandle(hSCManager);
		DWORD e = GetLastError();
		if (e == ERROR_SERVICE_EXISTS) {
			MessageBoxA(NULL, "service alresdy exists", "Error", 0);
		} else {
			MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error installing service", 0);
		}
		return -1;
	}
	CloseServiceHandle(hService);

	CloseServiceHandle(hSCManager);
	MessageBoxA(NULL, "installed successfully", "Info", 0);
	return 0;
}

bool uninstallService() {
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	if (!hSCManager) {
		DWORD e = GetLastError();
		if (e == ERROR_ACCESS_DENIED) {
			MessageBoxA(NULL, "access denied", "Error", 0);
		} else {
			MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error opening manager", 0);
		}
		return -1;
	}

	SC_HANDLE hService = OpenServiceW(hSCManager, L"MTUCI_AntimalwareService", SERVICE_STOP | DELETE);

	if (!hService) {
		CloseServiceHandle(hSCManager);
		DWORD e = GetLastError();
		MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error removing service", 0);
		return -1;
	}

	DeleteService(hService);
	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	MessageBoxA(NULL, "removed successfully", "Info", 0);
	return 0;
}

bool runService() {
	SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
	SC_HANDLE hService = OpenService(hSCManager, L"MTUCI_AntimalwareService", SERVICE_START);

	if (!StartService(hService, 0, NULL)) {
		CloseServiceHandle(hSCManager);
		MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error starting service", 0);
		return -1;
	}

	CloseServiceHandle(hService);
	CloseServiceHandle(hSCManager);
	MessageBoxA(NULL, "started successfully", "Info", 0);
	return 0;
}

DWORD WINAPI ReadPipe(LPVOID lpParameter) {
	char buffer[2048];
	DWORD numberOfBytesRead;
	DWORD ret;
	char id = (char)lpParameter;

	while (true) {
		ConnectNamedPipe(pipe, NULL);
		ret = ReadFile(pipe, buffer, 2048, &numberOfBytesRead, NULL);
		DWORD status = GetLastError();
		if (ret != 0 && numberOfBytesRead > 0) {
			//std::string res(buffer);
			if(strcmp(buffer, "stop") == 0){
				SetEvent(ghSvcStopEvent);
			}
		} else {
			DisconnectNamedPipe(pipe);
		}
		Sleep(500);
	}
	return 0;
}

//
// Purpose: 
//   Entry point for the service
//
// Parameters:
//   dwArgc - Number of arguments in the lpszArgv array
//   lpszArgv - Array of strings. The first string is the name of
//     the service and subsequent strings are passed by the process
//     that called the StartService function to start the service.
// 
// Return value:
//   None.
//
VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR* lpszArgv) {
	// Register the handler function for the service

	gSvcStatusHandle = RegisterServiceCtrlHandler(
		SVCNAME,
		SvcCtrlHandler);

	if (!gSvcStatusHandle) {
		//SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
		return;
	}

	// These SERVICE_STATUS members remain as set here

	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSvcStatus.dwServiceSpecificExitCode = 0;

	// Report initial status to the SCM

	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

	// Perform service-specific initialization and work.
	pipe = CreateNamedPipeA("\\\\.\\pipe\\MTUCI_Antimalware_pipe", PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, 1, 512, 512, 5000, NULL);
	if (pipe == INVALID_HANDLE_VALUE) {
		return;
	}

	DWORD threadID;
	HANDLE hThread;
	hThread = CreateThread(NULL, 0, &ReadPipe, (LPVOID)1, 0, &threadID);

	SvcInit(dwArgc, lpszArgv);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;
	int iResult;

	if (wcscmp(lpCmdLine, L"") == 0) {
		SERVICE_TABLE_ENTRY DispatchTable[] =
		{
			{ (LPWSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain },
			{ NULL, NULL }
		};

		// This call returns when the service has stopped. 
		// The process should simply terminate when the call returns.

		if (!StartServiceCtrlDispatcher(DispatchTable)) {
			//SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
		}
	} else if (wcscmp(lpCmdLine, L"install") == 0) {
		installService();
	} else if (wcscmp(lpCmdLine, L"uninstall") == 0) {
		uninstallService();
	} else if (wcscmp(lpCmdLine, L"run") == 0) {
		runService();
	}

	DWORD threadID;
	HANDLE hServiceThread = CreateThread(NULL, 0, &clientThread, 0, 0, &threadID);

	return 0;
}
