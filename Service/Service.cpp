#pragma warning (disable : 4996)
#pragma once


#define DEFAULT_BUFLEN 512
#define BUFSIZE 512
// ‘айлы заголовков Windows
#include <windows.h>
#include <string>
//#include "Scanner.cpp"
#include <psapi.h>
#include <Shlwapi.h>
#include <vector>
#include <queue>
#include <unordered_map>
#include <aclapi.h>
#include <tlhelp32.h>
#include <openssl/ssl.h>

#include "ServiceManager.h"
#include "Scanner.h"
#include "Monitoring.h"
#include "Schedule.h"
#include "FileOperations.h"

#pragma comment(lib, "Ws2_32.lib")

#define SVCNAME TEXT("MTUCI_AntimalwareService")

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

struct WaitParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

struct MonitoringParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
};

struct ScannerParameters {
	bool* flagStop;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

struct ScheduleParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
};

struct WriterParameters {
	HANDLE hPipe;
	std::queue<ScanResult>* scanResults;
};

struct InstanceParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	HANDLE hPipe;
	std::queue<const wchar_t*>* toScan;
};

std::queue<const wchar_t*> toScan;
HANDLE hQueueEvent;
HANDLE hQueueMutex;

std::queue<ScanResult> scanResults;
HANDLE hResultsEvent;
HANDLE hResultsMutex;

SERVICE_STATUS          gSvcStatus;
SERVICE_STATUS_HANDLE   gSvcStatusHandle;
HANDLE                  ghSvcStopEvent = NULL;
HANDLE event_log;

// √лобальные переменные:
HINSTANCE hInst; // текущий экземпл€р
ScannerParameters parameters;
bool flagStop = false;

bool ProcessScan(bool* flagStop, HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes, std::queue<const wchar_t*>* paths) {

	//const wchar_t* message = L"process scan";
	//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	DWORD cbWritten;
	bool fSuccess = true;
	*flagStop = false;

	if (wcsncmp(pchRequest, L"SCAN", 4) == 0 && pchRequest[4] != L'\\') {

		//message = L"go open mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, L"MTUCI_AntimalwareService_QueueMutex");
		HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, false, L"MTUCI_AntimalwareService_QueueEvent");

		if (hEvent == 0) {
			//message = L"fail open event";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		//message = L"go wait mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hMutex, INFINITE);

		//message = L"push path";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		(*paths).push(pchRequest + 4);
		if (SetEvent(hEvent) == 0) {
			//message = L"fail set event";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		//message = L"release mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		ReleaseMutex(hMutex);

		const char* fin = "DONE\n";
		fSuccess = WriteFile(
			hPipe,        // handle to pipe 
			fin,     // buffer to write from 
			strlen(fin) * sizeof(char), // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O

	}
	return fSuccess;
}

DWORD WINAPI WriterThread(LPVOID lpvParam) {
	DWORD cbWritten;
	HANDLE hPipe = (*(WriterParameters*)lpvParam).hPipe;
	std::queue<ScanResult>* results = (*(WriterParameters*)lpvParam).scanResults;

	HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, L"MTUCI_AntimalwareService_ResultsMutex");
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, false, L"MTUCI_AntimalwareService_ResultsEvent");

	TCHAR chReply[BUFSIZE * sizeof(TCHAR)];
	CHAR mbsReply[550];
	std::wstring response;

	const wchar_t* message = L"WRITER enter to while";
	ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	while (true) {
		//message = L"WRITER wait event";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hEvent, INFINITE);

		//message = L"WRITER wait mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hMutex, INFINITE);

		//message = L"WRITER enter mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		while ((*results).size() > 0) {
			ScanResult result = (*results).front();
			(*results).pop();

			if ((*results).size() == 0) {
				ResetEvent(hEvent);
			}

			if (!result.isMalware) {
				continue;
			}

			response = std::wstring(result.file).append(L"?").append(result.name.begin(), result.name.end()).append(L"\n");
			
			//message = response.c_str();
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);


			int bytes = WideCharToMultiByte(CP_UTF8, 0, response.c_str(), -1, (LPSTR)chReply, BUFSIZE * sizeof(TCHAR), NULL, NULL);

			DWORD etewf = WriteFile(
				hPipe,        // handle to pipe 
				chReply,     // buffer to write from 
				bytes - 1, // number of bytes to write 
				&cbWritten,   // number of bytes written 
				NULL);        // not overlapped I/O 
		}
		ReleaseMutex(hMutex);
		//message = L"WRITER released mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
	}
}

bool ProcessSuspend(HANDLE hScannerThread) {
	return SuspendThread(hScannerThread) != -1;
}

bool ProcessContinue(HANDLE hScannerThread) {
	return ResumeThread(hScannerThread) != -1;
}

bool ProcessStop(bool* flagStop, std::queue<const wchar_t*>* paths) {
	*flagStop = true;
	WaitForSingleObject(hQueueMutex, INFINITE);

	while ((*paths).size() > 0) {
		(*paths).pop();
	}

	ResetEvent(hQueueEvent);

	ReleaseMutex(hQueueMutex);
	return true;
}

bool ProcessAddMonitoring(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	FILE* fp;
	int len = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\monitoring.dat");
	
	fp = _wfopen(szFile, L"r+b");

	int posInQuarant = 0;
	wchar_t letters[MAX_PATH];
	int filePos = 0;
	// check if already exists
	while ((fgetws(letters, MAX_PATH, fp)) != NULL) {
		len = wcslen(letters);
		letters[len - 1] = L'\0';
		if (wcscmp(pchRequest + 4, letters) == 0) {
			return true;
		}
		posInQuarant++;
		filePos = ftell(fp);
	}

	fseek(fp, 0, SEEK_END);
	fwrite(pchRequest + 4, wcslen(pchRequest) - 4, sizeof(TCHAR), fp);
	fwrite(L"\n", 1, sizeof(TCHAR), fp);
	fclose(fp);

	return true;
}

bool ProcessAddSchedule(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	FILE* fp;
	int len = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\schedulePaths.dat");

	fp = _wfopen(szFile, L"r+b");

	int posInQuarant = 0;
	wchar_t letters[MAX_PATH];
	int filePos = 0;
	// check if already exists
	while ((fgetws(letters, MAX_PATH, fp)) != NULL) {
		len = wcslen(letters);
		letters[len - 1] = L'\0';
		if (wcscmp(pchRequest + 4, letters) == 0) {
			return true;
		}
		posInQuarant++;
		filePos = ftell(fp);
	}

	fseek(fp, 0, SEEK_END);
	fwrite(pchRequest + 4, wcslen(pchRequest) - 4, sizeof(TCHAR), fp);
	fwrite(L"\n", 1, sizeof(TCHAR), fp);
	fclose(fp);

	return true;
}

bool ProcessClearMonitoring(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	FILE* fp;
	int len = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\monitoring.dat");

	fp = _wfopen(szFile, L"w");
	fclose(fp);

	return true;
}

bool ProcessClearQuarantine(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	FILE* fp;
	int len = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\quarantine.dat");

	fp = _wfopen(szFile, L"w");
	fclose(fp);

	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\quarantine\0\0");
	SHFILEOPSTRUCT fileOp;
	memset(&fileOp, 0, sizeof(SHFILEOPSTRUCT));
	fileOp.hwnd = NULL;
	fileOp.wFunc = FO_DELETE;
	fileOp.pFrom = szFile;
	fileOp.pTo = NULL;
	fileOp.fFlags = FOF_ALLOWUNDO;
	int res = SHFileOperation(&fileOp);
	CreateDirectory(szFile, NULL);

	return true;
}

bool ProcessClearSchedule(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	FILE* fp;
	int len = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\schedulePaths.dat");

	fp = _wfopen(szFile, L"w");
	fclose(fp);

	return true;
}

DWORD WINAPI InstanceThread(LPVOID lpvParam) {
	SHA256_CTX sha256;
	DWORD cbBytesReadReq = 0, cbBytesReadData = 0, cbReplyBytes = 0, cbWritten = 0;
	BOOL fSuccess = FALSE;
	TCHAR chRequest[BUFSIZE];
	TCHAR  chReply[BUFSIZE];
	std::queue<const wchar_t*>* paths = (*(InstanceParameters*)lpvParam).toScan;
	HANDLE hPipe = (*(InstanceParameters*)lpvParam).hPipe;

	ULONG PID;
	GetNamedPipeClientProcessId(hPipe, &PID);
	TCHAR filename[MAX_PATH];
	HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);

	if (processHandle != NULL) {
		if (GetModuleFileNameEx(processHandle, NULL, filename, MAX_PATH) != 0) {
			FILE* file = _wfopen(filename, L"rb");
			if (!file) {
				return -1;
			}

			unsigned char hash[SHA256_DIGEST_LENGTH];
			SHA256_CTX sha256;
			SHA256_Init(&sha256);
			const int bufSize = 32768;
			char* buffer = (char*)malloc(bufSize);
			int bytesRead = 0;
			if (!buffer) {
				return -1;
			}
			while ((bytesRead = fread(buffer, 1, bufSize, file))) {
				SHA256_Update(&sha256, buffer, bytesRead);
			}
			SHA256_Final(hash, &sha256);

			fclose(file);
			free(buffer);

			unsigned char trueHash[32] = { 0x79, 0xCD, 0x29, 0xE1, 0x22, 0x03, 0xBE, 0xCB, 0x66, 0x0D, 0x2C, 0x32, 0x7A, 0x90, 0xCF, 0x77, 0x52, 0x63, 0x7C, 0x77, 0xBA, 0x5B, 0xF8, 0x08, 0xCC, 0xBE, 0xF2, 0x2E, 0x9F, 0xEC, 0xE4, 0x0A };

			if (memcmp(hash, trueHash, 32) != 0) {
				const wchar_t* messages = L"хеш не совпал";
				ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
				CloseHandle(hPipe);
				return -1; // хеш не совпал
			}
			const wchar_t* messages = L"хеш совпал";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);
		} else {
			//tcout << "Module filename is: " << filename << endl;
			return -1;
		}
	} else {
		return -1;
	}

	// Loop until done reading
	while (true) {

		DWORD totalBytesAvail = 0;
		while (true) {
			PeekNamedPipe(hPipe, NULL, 0, NULL, &totalBytesAvail, NULL);
			if (totalBytesAvail == 0) {
				Sleep(500);
			} else {
				break;
			}
		}

		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile(
			hPipe,        // handle to pipe 
			chReply,    // buffer to receive data 
			BUFSIZE * sizeof(TCHAR), // size of buffer 
			&cbBytesReadReq, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesReadReq == 0) {
			break;
		}

		MultiByteToWideChar(CP_UTF8, 0, (LPCCH)chReply, -1, chRequest, BUFSIZE);

		const wchar_t* message = (LPCWSTR)chRequest + 10;
		ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		
		bool ansResult = true;

		if (wcsncmp(chRequest, L"SCAN", 4) == 0) {
			ansResult = ProcessScan((*(InstanceParameters*)lpvParam).flagStop, hPipe, chRequest, &cbReplyBytes, &toScan);
		}

		if (wcsncmp(chRequest, L"REMV", 4) == 0) {
			ansResult = ProcessRemove(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"QUAR", 4) == 0) {
			ansResult = ProcessQuarantine(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"REST", 4) == 0) {
			ansResult = ProcessRestore(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"SUSP", 4) == 0) {
			ansResult = ProcessSuspend((*(InstanceParameters*)lpvParam).hScannerThread);
		}

		if (wcsncmp(chRequest, L"CONT", 4) == 0) {
			ansResult = ProcessContinue((*(InstanceParameters*)lpvParam).hScannerThread);
		}

		if (wcsncmp(chRequest, L"STOP", 4) == 0) {
			ansResult = ProcessStop((*(InstanceParameters*)lpvParam).flagStop, &toScan);
		}

		if (wcsncmp(chRequest, L"ADDM", 4) == 0) {
			ansResult = ProcessAddMonitoring(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"CLRM", 4) == 0) {
			ansResult = ProcessClearMonitoring(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"CLRQ", 4) == 0) {
			ansResult = ProcessClearQuarantine(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"ADDS", 4) == 0) {
			ansResult = ProcessAddSchedule(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"CLRS", 4) == 0) {
			ansResult = ProcessClearSchedule(hPipe, chRequest, &cbReplyBytes);
		}

		if (!ansResult) {
			break;
		}
	}

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);
	CloseHandle(hPipe);

	return 1;
}

DWORD WINAPI WatchdogThread(LPVOID lpvParam) {
	HANDLE hProcess;
	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\Watchdog.exe");
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	while (true) {
		HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

		if (Process32First(snapshot, &entry)) {
			while (Process32Next(snapshot, &entry)) {
				if (wcsicmp(entry.szExeFile, L"Watchdog.exe") == 0) {
					HANDLE hProcess = OpenProcess(SYNCHRONIZE, false, entry.th32ProcessID);
					if (hProcess == 0) {
						Sleep(1000);
						break;
					}

					const wchar_t* message = L"Watchdog running";
					ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

					WaitForSingleObject(hProcess, INFINITE);
					break;
				}
			}
			Sleep(5000); // debug
			STARTUPINFO cif;
			ZeroMemory(&cif, sizeof(STARTUPINFO));
			PROCESS_INFORMATION pi;
			CreateProcess(NULL, szFile, NULL, NULL, FALSE, NULL, NULL, NULL, &cif, &pi);
		}
		CloseHandle(snapshot);
	}
}

VOID ReportSvcStatus(DWORD dwCurrentState,
	DWORD dwWin32ExitCode,
	DWORD dwWaitHint) {
	static DWORD dwCheckPoint = 1;

	gSvcStatus.dwCurrentState = dwCurrentState;
	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
	gSvcStatus.dwWaitHint = dwWaitHint;

	if (dwCurrentState == SERVICE_START_PENDING)
		gSvcStatus.dwControlsAccepted = 0;
	//else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

	if ((dwCurrentState == SERVICE_RUNNING) ||
		(dwCurrentState == SERVICE_STOPPED))
		gSvcStatus.dwCheckPoint = 0;
	else gSvcStatus.dwCheckPoint = dwCheckPoint++;

	// Report the status of the service to the SCM.
	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

VOID SvcInit(DWORD dwArgc, LPTSTR * lpszArgv) {

	ghSvcStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

	if (ghSvcStopEvent == NULL) {
		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}

	// Report running status when initialization is complete.

	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

	// TO_DO: Perform work until service stops.

	while (1) {
		// Check whether to stop the service.

		WaitForSingleObject(ghSvcStopEvent, INFINITE);

		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}
}

VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
	// Handle the requested control code. 

	switch (dwCtrl) {
	case SERVICE_CONTROL_STOP:
		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

		// Signal the service to stop.

		SetEvent(ghSvcStopEvent);
		ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);

		return;

	case SERVICE_CONTROL_INTERROGATE:
		break;

	default:
		break;
	}

}

DWORD WINAPI WaitConnect(LPVOID lpParameter) {
	HANDLE pipe;
	DWORD dwThreadId;

	while (true) {
		pipe = CreateNamedPipe(L"\\\\.\\pipe\\MTUCI_Antimalware_pipe", PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 512, 512, 5000, NULL);
		if (pipe == INVALID_HANDLE_VALUE) {
			return -1;
		}
		bool fConnected = ConnectNamedPipe(pipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
		if (fConnected) {

			const wchar_t* message = L"connected";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

			InstanceParameters param { (*(WaitParameters*)lpParameter).flagStop, (*(WaitParameters*)lpParameter).hScannerThread, pipe, (*(WaitParameters*)lpParameter).toScan };
			WriterParameters paramw { pipe, (*(WaitParameters*)lpParameter).scanResults };

			// Create a thread for this client. 
			HANDLE hThread = CreateThread(NULL, 0, InstanceThread, (LPVOID)&param, 0, &dwThreadId);

			HANDLE hWThread = CreateThread(NULL, 0, WriterThread, (LPVOID)&paramw, 0, &dwThreadId);

			if (hThread == NULL) {
				const wchar_t* message = L"exit1";
				ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
				return -1;
			} else {
				CloseHandle(hThread);
			}
		} else {

			// The client could not connect, so close the pipe. 
			CloseHandle(pipe);
		}
	}
	return 0;
}

VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR * lpszArgv) {
	// Register the handler function for the service

	gSvcStatusHandle = RegisterServiceCtrlHandler(
		SVCNAME,
		SvcCtrlHandler);

	if (!gSvcStatusHandle) {
		//SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
		return;
	}

	// These SERVICE_STATUS members remain as set here

	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSvcStatus.dwServiceSpecificExitCode = 0;

	// Report initial status to the SCM

	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

	// Perform service-specific initialization and work.

	DWORD waitConnectThreadID;
	HANDLE hWaitConnectThread;
	DWORD scannerThreadID;
	HANDLE hScannerThread;
	DWORD monitoringThreadID;
	HANDLE hMonitoringThread;
	DWORD scheduleThreadID;
	HANDLE hScheduleThread;
	DWORD watchdogThreadID;
	HANDLE hWatchdogThread;

	event_log = RegisterEventSource(NULL, SVCNAME);
	//ProtectProcess();

	hQueueEvent = CreateEvent(NULL, true, false, L"MTUCI_AntimalwareService_QueueEvent");
	hQueueMutex = CreateMutex(NULL, false, L"MTUCI_AntimalwareService_QueueMutex");
	hResultsEvent = CreateEvent(NULL, true, false, L"MTUCI_AntimalwareService_ResultsEvent");
	hResultsMutex = CreateMutex(NULL, false, L"MTUCI_AntimalwareService_ResultsMutex");

	ScannerParameters sparameters = ScannerParameters{ &flagStop, &toScan, &scanResults };
	hScannerThread = CreateThread(NULL, 0, &ScannerThread, (LPVOID)&sparameters, 0, &scannerThreadID);

	WaitParameters wparameters = WaitParameters{ &flagStop, hScannerThread, &toScan, &scanResults };
	hWaitConnectThread = CreateThread(NULL, 0, &WaitConnect, (LPVOID)&wparameters, 0, &waitConnectThreadID);

	MonitoringParameters mparameters = MonitoringParameters{ &flagStop, hScannerThread, &toScan };
	hMonitoringThread = CreateThread(NULL, 0, &MonitoringThread, (LPVOID)&mparameters, 0, &monitoringThreadID);

	ScheduleParameters scparameters = ScheduleParameters{ &flagStop, hScannerThread, &toScan };
	hScheduleThread = CreateThread(NULL, 0, &ScheduleThread, (LPVOID)&scparameters, 0, &scheduleThreadID);

	hWatchdogThread = CreateThread(NULL, 0, &WatchdogThread, (LPVOID)0, 0, &watchdogThreadID);

	SvcInit(dwArgc, lpszArgv);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;
	int iResult;

	if (wcscmp(lpCmdLine, L"") == 0) {
		SERVICE_TABLE_ENTRY DispatchTable[] =
		{
			{ (LPWSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain },
			{ NULL, NULL }
		};

		// This call returns when the service has stopped. 
		// The process should simply terminate when the call returns.

		if (!StartServiceCtrlDispatcher(DispatchTable)) {
			//SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
		}
	} else if (wcscmp(lpCmdLine, L"install") == 0) {
		installService();
	} else if (wcscmp(lpCmdLine, L"uninstall") == 0) {
		uninstallService();
	} else if (wcscmp(lpCmdLine, L"run") == 0) {
		runService();
	}

	DWORD threadID;
	//HANDLE hServiceThread = CreateThread(NULL, 0, &clientThread, 0, 0, &threadID);

	return 0;
}
