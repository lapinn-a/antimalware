#pragma warning (disable : 4996)
#pragma once


#define DEFAULT_BUFLEN 512
#define BUFSIZE 512
// ‘айлы заголовков Windows
#include <windows.h>
#include <string>
//#include "Scanner.cpp"
#include <psapi.h>
#include <Shlwapi.h>
#include <vector>
#include <queue>
#include <unordered_map>
#include <aclapi.h>

#pragma comment(lib, "Ws2_32.lib")

#define SVCNAME TEXT("MTUCI_AntimalwareService")

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

struct WaitParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

struct MonitoringParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

struct ScannerParameters {
	bool* flagStop;
	std::queue<const wchar_t*>* toScan;
	std::queue<ScanResult>* scanResults;
};

struct WriterParameters {
	HANDLE hPipe;
	std::queue<ScanResult>* scanResults;
};

struct InstanceParameters {
	bool* flagStop;
	HANDLE hScannerThread;
	HANDLE hPipe;
	std::queue<const wchar_t*>* toScan;
};

int installService();
int uninstallService();
int runService();
std::vector<ScanResult> scan(std::vector<const wchar_t*> path, size_t bufferSize, std::unordered_multimap<uint64_t, Signature>* signatures);
DWORD WINAPI ScannerThread(LPVOID lpvParam);
DWORD WINAPI MonitoringThread(LPVOID lpvParam);

std::queue<const wchar_t*> toScan;
HANDLE hQueueEvent;
HANDLE hQueueMutex;

std::queue<ScanResult> scanResults;
HANDLE hResultsEvent;
HANDLE hResultsMutex;

SERVICE_STATUS          gSvcStatus;
SERVICE_STATUS_HANDLE   gSvcStatusHandle;
HANDLE                  ghSvcStopEvent = NULL;
HANDLE event_log;

// √лобальные переменные:
HINSTANCE hInst; // текущий экземпл€р
ScannerParameters parameters;
bool flagStop = false;

bool ProcessScan(bool* flagStop, HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes, std::queue<const wchar_t*>* paths) {

	//const wchar_t* message = L"process scan";
	//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	DWORD cbWritten;
	bool fSuccess = true;
	*flagStop = false;

	if (wcsncmp(pchRequest, L"SCAN", 4) == 0 && pchRequest[4] != L'\\') {

		//message = L"go open mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, L"MTUCI_AntimalwareService_QueueMutex");
		HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, false, L"MTUCI_AntimalwareService_QueueEvent");

		if (hEvent == 0) {
			//message = L"fail open event";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		//message = L"go wait mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hMutex, INFINITE);

		//message = L"push path";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		(*paths).push(pchRequest + 4);
		if (SetEvent(hEvent) == 0) {
			//message = L"fail set event";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		}

		//message = L"release mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		ReleaseMutex(hMutex);

		const char* fin = "DONE\n";
		fSuccess = WriteFile(
			hPipe,        // handle to pipe 
			fin,     // buffer to write from 
			strlen(fin) * sizeof(char), // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O

	}
	return fSuccess;
}

DWORD WINAPI WriterThread(LPVOID lpvParam) {
	DWORD cbWritten;
	HANDLE hPipe = (*(WriterParameters*)lpvParam).hPipe;
	std::queue<ScanResult>* results = (*(WriterParameters*)lpvParam).scanResults;

	HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, L"MTUCI_AntimalwareService_ResultsMutex");
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, false, L"MTUCI_AntimalwareService_ResultsEvent");

	TCHAR chReply[BUFSIZE * sizeof(TCHAR)];
	CHAR mbsReply[550];
	std::wstring response;

	const wchar_t* message = L"WRITER enter to while";
	ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	while (true) {
		//message = L"WRITER wait event";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hEvent, INFINITE);

		//message = L"WRITER wait mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		WaitForSingleObject(hMutex, INFINITE);

		//message = L"WRITER enter mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

		while ((*results).size() > 0) {
			ScanResult result = (*results).front();
			(*results).pop();

			if ((*results).size() == 0) {
				ResetEvent(hEvent);
			}

			if (!result.isMalware) {
				continue;
			}

			response = std::wstring(result.file).append(L"?").append(result.name.begin(), result.name.end()).append(L"\n");
			
			//message = response.c_str();
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);


			int bytes = WideCharToMultiByte(CP_UTF8, 0, response.c_str(), -1, (LPSTR)chReply, BUFSIZE * sizeof(TCHAR), NULL, NULL);

			DWORD etewf = WriteFile(
				hPipe,        // handle to pipe 
				chReply,     // buffer to write from 
				bytes - 1, // number of bytes to write 
				&cbWritten,   // number of bytes written 
				NULL);        // not overlapped I/O 
		}
		ReleaseMutex(hMutex);
		//message = L"WRITER released mutex";
		//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
	}
}

bool ProcessRemove(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	std::vector<const wchar_t*> toRemove;
	toRemove.push_back(pchRequest + 4);

	SHFILEOPSTRUCT fileOp;
	memset(&fileOp, 0, sizeof(SHFILEOPSTRUCT));
	fileOp.hwnd = NULL;
	fileOp.wFunc = FO_DELETE;
	fileOp.pFrom = pchRequest + 4;
	fileOp.pTo = NULL;
	fileOp.fFlags = FOF_ALLOWUNDO;
	int res = SHFileOperation(&fileOp);

	if (res != 0) {
		fSuccess = false;
	} else {
		fSuccess = true;
	}

	const char* fin = "DONE\n";
	fSuccess = WriteFile(
		hPipe,        // handle to pipe 
		fin,     // buffer to write from 
		strlen(fin) * sizeof(char), // number of bytes to write 
		&cbWritten,   // number of bytes written 
		NULL);        // not overlapped I/O
	return fSuccess;
}

bool ProcessQuarantine(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	std::vector<const wchar_t*> toRemove;
	toRemove.push_back(pchRequest + 4);

	FILE* fileptr;
	unsigned int count = 0;
	wchar_t chr = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\quarantine.dat");

	fileptr = _wfopen(szFile, L"r+b");

	chr = fgetwc(fileptr);
	while (chr != WEOF) {
		if (chr == L'\n') {
			count++;
		}
		chr = fgetwc(fileptr);
	}

	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);

	bool res = MoveFileEx(pchRequest + 4, std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str(), MOVEFILE_COPY_ALLOWED);

	//const wchar_t* messages = std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str();
	//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

	fwrite(pchRequest + 4, wcslen(pchRequest) - 4, sizeof(TCHAR), fileptr);
	fwrite(L"\n", 1, sizeof(TCHAR), fileptr);
	fclose(fileptr);

	fileptr = _wfopen(std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str(), L"r+b");
	for (int i = 0; i < 42; i++) {
		fseek(fileptr, i, SEEK_SET);
		chr = getc(fileptr);
		fseek(fileptr, i, SEEK_SET);
		fputc(chr^85, fileptr);
	}
	fclose(fileptr);

	const char* fin;
	if (res != 0) {
		fin = "DONE\n";
	} else {
		fin = "FAIL\n";
	}

	fSuccess = WriteFile(
		hPipe,        // handle to pipe 
		fin,     // buffer to write from 
		strlen(fin) * sizeof(char), // number of bytes to write 
		&cbWritten,   // number of bytes written 
		NULL);        // not overlapped I/O
	return fSuccess;
}

bool ProcessSuspend(HANDLE hScannerThread) {
	return SuspendThread(hScannerThread) != -1;
}

bool ProcessContinue(HANDLE hScannerThread) {
	return ResumeThread(hScannerThread) != -1;
}

bool ProcessStop(bool* flagStop, std::queue<const wchar_t*>* paths) {
	*flagStop = true;
	WaitForSingleObject(hQueueMutex, INFINITE);

	while ((*paths).size() > 0) {
		(*paths).pop();
	}

	ResetEvent(hQueueEvent);

	ReleaseMutex(hQueueMutex);
	return true;
}

DWORD WINAPI InstanceThread(LPVOID lpvParam) {
	DWORD cbBytesReadReq = 0, cbBytesReadData = 0, cbReplyBytes = 0, cbWritten = 0;
	BOOL fSuccess = FALSE;
	TCHAR chRequest[BUFSIZE];
	TCHAR  chReply[BUFSIZE];
	std::queue<const wchar_t*>* paths = (*(InstanceParameters*)lpvParam).toScan;
	HANDLE hPipe = (*(InstanceParameters*)lpvParam).hPipe;

	// Loop until done reading
	while (true) {
		ULONG PID;
		GetNamedPipeClientProcessId(hPipe, &PID);
		TCHAR filename[MAX_PATH];
		HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);
		if (processHandle != NULL) {
			if (GetModuleFileNameEx(processHandle, NULL, filename, MAX_PATH) == 0) {
				//tcerr << "Failed to get module filename." << endl;
				return -1;
			} else {
				//tcout << "Module filename is: " << filename << endl;

			}
			CloseHandle(processHandle);
		} else {
			//tcerr << "Failed to open process." << endl;
			return -1;
		}

		DWORD totalBytesAvail = 0;
		while (true) {
			PeekNamedPipe(hPipe, NULL, 0, NULL, &totalBytesAvail, NULL);
			if (totalBytesAvail == 0) {
				Sleep(500);
			} else {
				break;
			}
		}

		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile(
			hPipe,        // handle to pipe 
			chReply,    // buffer to receive data 
			BUFSIZE * sizeof(TCHAR), // size of buffer 
			&cbBytesReadReq, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesReadReq == 0) {
			if (GetLastError() == ERROR_BROKEN_PIPE) {
				//_tprintf(TEXT("InstanceThread: client disconnected.\n"));
			} else {
				//_tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"), GetLastError());
			}
			const wchar_t* message = L"disconnected1";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			break;
		}

		//mbstowcs(chRequest, (char*)chReply, BUFSIZE * sizeof(TCHAR));
		MultiByteToWideChar(CP_UTF8, 0, (LPCCH)chReply, -1, chRequest, BUFSIZE);

		const wchar_t* message = (LPCWSTR)chRequest + 10;
		ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
		
		bool ansResult;

		if (wcsncmp(chRequest, L"SCAN", 4) == 0) {
			ansResult = ProcessScan((*(InstanceParameters*)lpvParam).flagStop, hPipe, chRequest, &cbReplyBytes, &toScan);
		}

		if (wcsncmp(chRequest, L"REMV", 4) == 0) {
			ansResult = ProcessRemove(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"QUAR", 4) == 0) {
			ansResult = ProcessQuarantine(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"SUSP", 4) == 0) {
			ansResult = ProcessSuspend((*(InstanceParameters*)lpvParam).hScannerThread);
		}

		if (wcsncmp(chRequest, L"CONT", 4) == 0) {
			ansResult = ProcessContinue((*(InstanceParameters*)lpvParam).hScannerThread);
		}

		if (wcsncmp(chRequest, L"STOP", 4) == 0) {
			ansResult = ProcessStop((*(InstanceParameters*)lpvParam).flagStop, &toScan);
		}

		if (!ansResult) {
			break;
		}
	}

	//const wchar_t* message = L"disconnected";
	//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);
	CloseHandle(hPipe);

	return 1;
}

DWORD ProtectProcess(void) {
	HANDLE hProcess = GetCurrentProcess();
	PACL pEmptyDacl;
	DWORD dwErr;

	// using malloc guarantees proper alignment
	pEmptyDacl = (PACL)malloc(sizeof(ACL));

	if (!InitializeAcl(pEmptyDacl, sizeof(ACL), ACL_REVISION)) {
		dwErr = GetLastError();
	} else {
		dwErr = SetSecurityInfo(hProcess, SE_KERNEL_OBJECT,
			DACL_SECURITY_INFORMATION, NULL, NULL, pEmptyDacl, NULL);
	}

	free(pEmptyDacl);
	return dwErr;
}

DWORD WINAPI WatchdogThread(LPVOID lpvParam) {
	HANDLE hProcess;
	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\Watchdog.exe");

	while (true) {
		return 0;
		//hProcess = GetModuleHandleA(szFile);

		//HANDLE hProcess = OpenProcess(SYNCHRONIZE, false, pid);
		//if (hProcess == 0) {
			//MessageBoxA(NULL, "process handle zero", "Watchdog:", 0);
			//Sleep(1000);
			//continue;
		//}

		//MessageBoxA(NULL, "starting wait", "Watchdog:", 0);
		//WaitForSingleObject(hProcess, INFINITE);
		//MessageBoxA(NULL, "restarting service", "Watchdog:", 0);
	}
}

VOID ReportSvcStatus(DWORD dwCurrentState,
	DWORD dwWin32ExitCode,
	DWORD dwWaitHint) {
	static DWORD dwCheckPoint = 1;

	gSvcStatus.dwCurrentState = dwCurrentState;
	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
	gSvcStatus.dwWaitHint = dwWaitHint;

	if (dwCurrentState == SERVICE_START_PENDING)
		gSvcStatus.dwControlsAccepted = 0;
	//else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

	if ((dwCurrentState == SERVICE_RUNNING) ||
		(dwCurrentState == SERVICE_STOPPED))
		gSvcStatus.dwCheckPoint = 0;
	else gSvcStatus.dwCheckPoint = dwCheckPoint++;

	// Report the status of the service to the SCM.
	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

VOID SvcInit(DWORD dwArgc, LPTSTR * lpszArgv) {

	ghSvcStopEvent = CreateEvent(
		NULL,    // default security attributes
		TRUE,    // manual reset event
		FALSE,   // not signaled
		NULL);   // no name

	if (ghSvcStopEvent == NULL) {
		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}

	// Report running status when initialization is complete.

	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

	// TO_DO: Perform work until service stops.

	while (1) {
		// Check whether to stop the service.

		WaitForSingleObject(ghSvcStopEvent, INFINITE);

		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}
}

VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
	// Handle the requested control code. 

	switch (dwCtrl) {
	case SERVICE_CONTROL_STOP:
		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

		// Signal the service to stop.

		SetEvent(ghSvcStopEvent);
		ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);

		return;

	case SERVICE_CONTROL_INTERROGATE:
		break;

	default:
		break;
	}

}

DWORD WINAPI WaitConnect(LPVOID lpParameter) {
	HANDLE pipe;
	DWORD dwThreadId;

	while (true) {
		pipe = CreateNamedPipe(L"\\\\.\\pipe\\MTUCI_Antimalware_pipe", PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 512, 512, 5000, NULL);
		if (pipe == INVALID_HANDLE_VALUE) {
			return -1;
		}
		bool fConnected = ConnectNamedPipe(pipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
		if (fConnected) {

			const wchar_t* message = L"connected";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

			InstanceParameters param { (*(WaitParameters*)lpParameter).flagStop, (*(WaitParameters*)lpParameter).hScannerThread, pipe, (*(WaitParameters*)lpParameter).toScan };
			WriterParameters paramw { pipe, (*(WaitParameters*)lpParameter).scanResults };

			// Create a thread for this client. 
			HANDLE hThread = CreateThread(
				NULL,              // no security attribute 
				0,                 // default stack size 
				InstanceThread,    // thread proc
				(LPVOID)&param,      // thread parameter 
				0,                 // not suspended 
				&dwThreadId);      // returns thread ID 

			HANDLE hWThread = CreateThread(
				NULL,              // no security attribute 
				0,                 // default stack size 
				WriterThread,    // thread proc
				(LPVOID)&paramw,      // thread parameter 
				0,                 // not suspended 
				&dwThreadId);      // returns thread ID 

			if (hThread == NULL) {
				const wchar_t* message = L"exit1";
				ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
				//_tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError());
				return -1;
			} else {
				CloseHandle(hThread);
			}
		} else {

			// The client could not connect, so close the pipe. 
			CloseHandle(pipe);
		}
	}
	return 0;
}

VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR * lpszArgv) {
	// Register the handler function for the service

	gSvcStatusHandle = RegisterServiceCtrlHandler(
		SVCNAME,
		SvcCtrlHandler);

	if (!gSvcStatusHandle) {
		//SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
		return;
	}

	// These SERVICE_STATUS members remain as set here

	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSvcStatus.dwServiceSpecificExitCode = 0;

	// Report initial status to the SCM

	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

	// Perform service-specific initialization and work.

	DWORD waitConnectThreadID;
	HANDLE hWaitConnectThread;
	DWORD scannerThreadID;
	HANDLE hScannerThread;
	DWORD monitoringThreadID;
	HANDLE hMonitoringThread;

	event_log = RegisterEventSource(NULL, SVCNAME);
	ProtectProcess();

	hQueueEvent = CreateEvent(NULL, true, false, L"MTUCI_AntimalwareService_QueueEvent");
	hQueueMutex = CreateMutex(NULL, false, L"MTUCI_AntimalwareService_QueueMutex");
	hResultsEvent = CreateEvent(NULL, true, false, L"MTUCI_AntimalwareService_ResultsEvent");
	hResultsMutex = CreateMutex(NULL, false, L"MTUCI_AntimalwareService_ResultsMutex");

	ScannerParameters sparameters = ScannerParameters{ &flagStop, &toScan, &scanResults };
	hScannerThread = CreateThread(NULL, 0, &ScannerThread, (LPVOID)&sparameters, 0, &scannerThreadID);

	WaitParameters wparameters = WaitParameters{ &flagStop, hScannerThread, &toScan, &scanResults };
	hWaitConnectThread = CreateThread(NULL, 0, &WaitConnect, (LPVOID)&wparameters, 0, &waitConnectThreadID);

	MonitoringParameters mparameters = MonitoringParameters{ &flagStop, hScannerThread, &toScan, &scanResults };
	hMonitoringThread = CreateThread(NULL, 0, &WaitConnect, (LPVOID)&mparameters, 0, &monitoringThreadID);

	SvcInit(dwArgc, lpszArgv);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;
	int iResult;

	if (wcscmp(lpCmdLine, L"") == 0) {
		SERVICE_TABLE_ENTRY DispatchTable[] =
		{
			{ (LPWSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain },
			{ NULL, NULL }
		};

		// This call returns when the service has stopped. 
		// The process should simply terminate when the call returns.

		if (!StartServiceCtrlDispatcher(DispatchTable)) {
			//SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
		}
	} else if (wcscmp(lpCmdLine, L"install") == 0) {
		installService();
	} else if (wcscmp(lpCmdLine, L"uninstall") == 0) {
		uninstallService();
	} else if (wcscmp(lpCmdLine, L"run") == 0) {
		runService();
	}

	DWORD threadID;
	//HANDLE hServiceThread = CreateThread(NULL, 0, &clientThread, 0, 0, &threadID);

	return 0;
}
