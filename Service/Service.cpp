#pragma warning (disable : 4996)
#pragma once


#define DEFAULT_BUFLEN 512
#define BUFSIZE 512
// Файлы заголовков Windows
#include <windows.h>
#include <string>
//#include "Scanner.cpp"
#include <psapi.h>
#include <vector>
#include <unordered_map>

#pragma comment(lib, "Ws2_32.lib")

#define SVCNAME TEXT("MTUCI_AntimalwareService")

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

int installService();
int uninstallService();
int runService();
std::vector<ScanResult> scan(std::vector<const wchar_t*> path, size_t bufferSize, std::unordered_multimap<uint64_t, Signature>* signatures);
std::unordered_multimap<uint64_t, Signature> parseBase();

SERVICE_STATUS          gSvcStatus;
SERVICE_STATUS_HANDLE   gSvcStatusHandle;
HANDLE                  ghSvcStopEvent = NULL;
HANDLE event_log;

// Глобальные переменные:
HINSTANCE hInst; // текущий экземпляр
std::unordered_multimap<uint64_t, Signature> base;



bool GetAnswerToRequest(HANDLE hPipe, LPTSTR pchRequest, LPTSTR pchReply, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	if (wcsncmp(pchRequest, L"SCAN", 4) == 0) {
		std::vector<const wchar_t*> toScan;
		toScan.push_back(pchRequest + 4);
		std::vector<ScanResult> res = scan(toScan, 104857600, &base);

		bool write = false;

		TCHAR chReply[550];
		CHAR mbsReply[550];
		std::string response;
		for (int i = 0; i < res.size(); i++) {
			if (!res[i].isMalware) {
				continue;
			}

			response.append(std::string(res[i].file.begin(), res[i].file.end())).append("?").append(res[i].name).append("\n");
			write = true;
		}

		response.append("DONE\n");
		const char* message = response.c_str();
		fSuccess = WriteFile(
			hPipe,        // handle to pipe 
			response.c_str(),     // buffer to write from 
			response.size(), // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O 
	}
	return fSuccess;
}

DWORD WINAPI InstanceThread(LPVOID lpvParam) {
	DWORD cbBytesReadReq = 0, cbBytesReadData = 0, cbReplyBytes = 0, cbWritten = 0;
	BOOL fSuccess = FALSE;
	TCHAR chRequest[BUFSIZE];
	TCHAR  chReply[BUFSIZE];
	HANDLE hPipe = (HANDLE)lpvParam;

	// Loop until done reading
	while (true) {
		ULONG PID;
		GetNamedPipeClientProcessId(hPipe, &PID);
		TCHAR filename[MAX_PATH];
		HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);
		if (processHandle != NULL) {
			if (GetModuleFileNameEx(processHandle, NULL, filename, MAX_PATH) == 0) {
				//tcerr << "Failed to get module filename." << endl;
				return -1;
			} else {
				//tcout << "Module filename is: " << filename << endl;

			}
			CloseHandle(processHandle);
		} else {
			//tcerr << "Failed to open process." << endl;
			return -1;
		}
		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile(
			hPipe,        // handle to pipe 
			chReply,    // buffer to receive data 
			BUFSIZE * sizeof(TCHAR), // size of buffer 
			&cbBytesReadReq, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesReadReq == 0) {
			if (GetLastError() == ERROR_BROKEN_PIPE) {
				//_tprintf(TEXT("InstanceThread: client disconnected.\n"));
			} else {
				//_tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"), GetLastError());
			}
			const wchar_t* message = L"disconnected1";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			break;
		}

		mbstowcs(chRequest, (char*)chReply, BUFSIZE * sizeof(TCHAR));
		bool ansResult = GetAnswerToRequest(hPipe, chRequest, chReply, &cbReplyBytes);

		if (!ansResult) {
			//_tprintf(TEXT("InstanceThread WriteFile failed, GLE=%d.\n"), GetLastError());
			const wchar_t* message = L"disconnected2";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			break;
		}
	}

	const wchar_t* message = L"disconnected";
	ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);
	CloseHandle(hPipe);

	//printf("InstanceThread exiting.\n");
	return 1;
}

VOID ReportSvcStatus(DWORD dwCurrentState,
	DWORD dwWin32ExitCode,
	DWORD dwWaitHint) {
	static DWORD dwCheckPoint = 1;

	gSvcStatus.dwCurrentState = dwCurrentState;
	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
	gSvcStatus.dwWaitHint = dwWaitHint;

	if (dwCurrentState == SERVICE_START_PENDING)
		gSvcStatus.dwControlsAccepted = 0;
	else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

	if ((dwCurrentState == SERVICE_RUNNING) ||
		(dwCurrentState == SERVICE_STOPPED))
		gSvcStatus.dwCheckPoint = 0;
	else gSvcStatus.dwCheckPoint = dwCheckPoint++;

	// Report the status of the service to the SCM.
	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

VOID SvcInit(DWORD dwArgc, LPTSTR * lpszArgv) {

	ghSvcStopEvent = CreateEvent(
		NULL,    // default security attributes
		TRUE,    // manual reset event
		FALSE,   // not signaled
		NULL);   // no name

	if (ghSvcStopEvent == NULL) {
		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}

	// Report running status when initialization is complete.

	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

	// TO_DO: Perform work until service stops.

	while (1) {
		// Check whether to stop the service.

		WaitForSingleObject(ghSvcStopEvent, INFINITE);

		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}
}

VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
	// Handle the requested control code. 

	switch (dwCtrl) {
	case SERVICE_CONTROL_STOP:
		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

		// Signal the service to stop.

		SetEvent(ghSvcStopEvent);
		ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);

		return;

	case SERVICE_CONTROL_INTERROGATE:
		break;

	default:
		break;
	}

}

DWORD WINAPI WaitConnect(LPVOID lpParameter) {
	HANDLE pipe;
	DWORD dwThreadId;

	while (true) {
		pipe = CreateNamedPipe(L"\\\\.\\pipe\\MTUCI_Antimalware_pipe", PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 512, 512, 5000, NULL);
		if (pipe == INVALID_HANDLE_VALUE) {
			return -1;
		}
		bool fConnected = ConnectNamedPipe(pipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
		if (fConnected) {

			const wchar_t* message = L"connected";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

			// Create a thread for this client. 
			HANDLE hThread = CreateThread(
				NULL,              // no security attribute 
				0,                 // default stack size 
				InstanceThread,    // thread proc
				(LPVOID)pipe,      // thread parameter 
				0,                 // not suspended 
				&dwThreadId);      // returns thread ID 

			if (hThread == NULL) {
				const wchar_t* message = L"exit1";
				ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
				//_tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError());
				return -1;
			} else {
				CloseHandle(hThread);
			}
		} else {

			// The client could not connect, so close the pipe. 
			CloseHandle(pipe);
		}
	}
	return 0;
}

VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR * lpszArgv) {
	// Register the handler function for the service

	gSvcStatusHandle = RegisterServiceCtrlHandler(
		SVCNAME,
		SvcCtrlHandler);

	if (!gSvcStatusHandle) {
		//SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
		return;
	}

	// These SERVICE_STATUS members remain as set here

	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSvcStatus.dwServiceSpecificExitCode = 0;

	// Report initial status to the SCM

	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

	// Perform service-specific initialization and work.

	DWORD waitConnectThreadID;
	HANDLE hWaitConnectThread;
	base = parseBase();

	event_log = RegisterEventSource(NULL, SVCNAME);

	hWaitConnectThread = CreateThread(NULL, 0, &WaitConnect, (LPVOID)1, 0, &waitConnectThreadID);

	SvcInit(dwArgc, lpszArgv);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;
	int iResult;

	if (wcscmp(lpCmdLine, L"") == 0) {
		SERVICE_TABLE_ENTRY DispatchTable[] =
		{
			{ (LPWSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain },
			{ NULL, NULL }
		};

		// This call returns when the service has stopped. 
		// The process should simply terminate when the call returns.

		if (!StartServiceCtrlDispatcher(DispatchTable)) {
			//SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
		}
	} else if (wcscmp(lpCmdLine, L"install") == 0) {
		installService();
	} else if (wcscmp(lpCmdLine, L"uninstall") == 0) {
		uninstallService();
	} else if (wcscmp(lpCmdLine, L"run") == 0) {
		runService();
	}

	DWORD threadID;
	//HANDLE hServiceThread = CreateThread(NULL, 0, &clientThread, 0, 0, &threadID);

	return 0;
}
