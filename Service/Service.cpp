#pragma warning (disable : 4996)
#pragma once


#define DEFAULT_BUFLEN 512
#define BUFSIZE 512
// ‘айлы заголовков Windows
#include <windows.h>
#include <string>
//#include "Scanner.cpp"
#include <psapi.h>
#include <Shlwapi.h>
#include <vector>
#include <unordered_map>
#include <aclapi.h>

#pragma comment(lib, "Ws2_32.lib")

#define SVCNAME TEXT("MTUCI_AntimalwareService")

#pragma pack(push, 1)
struct Signature {
	byte length;
	byte SHA256[32];
	uint64_t begin;
	uint64_t end;
	std::string name;
};
#pragma pack(pop)

struct ScanResult {
	std::wstring file;
	bool isMalware;
	std::string name;
};

int installService();
int uninstallService();
int runService();
std::vector<ScanResult> scan(std::vector<const wchar_t*> path, size_t bufferSize, std::unordered_multimap<uint64_t, Signature>* signatures);
std::unordered_multimap<uint64_t, Signature> parseBase();

SERVICE_STATUS          gSvcStatus;
SERVICE_STATUS_HANDLE   gSvcStatusHandle;
HANDLE                  ghSvcStopEvent = NULL;
HANDLE event_log;

// √лобальные переменные:
HINSTANCE hInst; // текущий экземпл€р
std::unordered_multimap<uint64_t, Signature> base;

bool ProcessScan(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	if (wcsncmp(pchRequest, L"SCAN", 4) == 0) {
		std::vector<const wchar_t*> toScan;
		toScan.push_back(pchRequest + 4);
		std::vector<ScanResult> res = scan(toScan, 104857600, &base);

		TCHAR chReply[BUFSIZE * sizeof(TCHAR)];
		CHAR mbsReply[550];
		std::wstring response;


		for (int i = 0; i < res.size(); i++) {
			if (!res[i].isMalware) {
				continue;
			}

			response = std::wstring(res[i].file).append(L"?").append(res[i].name.begin(), res[i].name.end()).append(L"\n");
			int bytes = WideCharToMultiByte(CP_UTF8, 0, response.c_str(), -1, (LPSTR)chReply, BUFSIZE * sizeof(TCHAR), NULL, NULL);

			fSuccess = WriteFile(
				hPipe,        // handle to pipe 
				chReply,     // buffer to write from 
				bytes - 1, // number of bytes to write 
				&cbWritten,   // number of bytes written 
				NULL);        // not overlapped I/O 
		}

		const char* fin = "DONE\n";
		fSuccess = WriteFile(
			hPipe,        // handle to pipe 
			fin,     // buffer to write from 
			strlen(fin) * sizeof(char), // number of bytes to write 
			&cbWritten,   // number of bytes written 
			NULL);        // not overlapped I/O

	}
	return fSuccess;
}

bool ProcessRemove(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	std::vector<const wchar_t*> toRemove;
	toRemove.push_back(pchRequest + 4);

	SHFILEOPSTRUCT fileOp;
	memset(&fileOp, 0, sizeof(SHFILEOPSTRUCT));
	fileOp.hwnd = NULL;
	fileOp.wFunc = FO_DELETE;
	fileOp.pFrom = pchRequest + 4;
	fileOp.pTo = NULL;
	fileOp.fFlags = FOF_ALLOWUNDO;
	int res = SHFileOperation(&fileOp);

	if (res != 0) {
		fSuccess = false;
	} else {
		fSuccess = true;
	}

	const char* fin = "DONE\n";
	fSuccess = WriteFile(
		hPipe,        // handle to pipe 
		fin,     // buffer to write from 
		strlen(fin) * sizeof(char), // number of bytes to write 
		&cbWritten,   // number of bytes written 
		NULL);        // not overlapped I/O
	return fSuccess;
}

bool ProcessQuarantine(HANDLE hPipe, LPTSTR pchRequest, LPDWORD pchBytes) {
	DWORD cbWritten;
	bool fSuccess = true;

	std::vector<const wchar_t*> toRemove;
	toRemove.push_back(pchRequest + 4);

	FILE* fileptr;
	unsigned int count = 0;
	wchar_t chr = 0;

	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\quarantine.dat");

	fileptr = _wfopen(szFile, L"r+b");

	chr = fgetwc(fileptr);
	while (chr != WEOF) {
		if (chr == L'\n') {
			count++;
		}
		chr = fgetwc(fileptr);
	}

	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);

	bool res = MoveFileEx(pchRequest + 4, std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str(), MOVEFILE_COPY_ALLOWED);

	const wchar_t* messages = std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str();
	ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &messages, NULL);

	fwrite(pchRequest + 4, wcslen(pchRequest) - 4, sizeof(TCHAR), fileptr);
	fwrite(L"\n", 1, sizeof(TCHAR), fileptr);
	fclose(fileptr);

	fileptr = _wfopen(std::wstring(szFile).append(L"\\quarantine\\").append(std::to_wstring(count)).append(L".virus").c_str(), L"r+b");
	for (int i = 0; i < 42; i++) {
		fseek(fileptr, i, SEEK_SET);
		chr = getc(fileptr);
		fseek(fileptr, i, SEEK_SET);
		fputc(chr^85, fileptr);
	}
	fclose(fileptr);

	const char* fin;
	if (res != 0) {
		fin = "DONE\n";
	} else {
		fin = "FAIL\n";
	}

	fSuccess = WriteFile(
		hPipe,        // handle to pipe 
		fin,     // buffer to write from 
		strlen(fin) * sizeof(char), // number of bytes to write 
		&cbWritten,   // number of bytes written 
		NULL);        // not overlapped I/O
	return fSuccess;
}

DWORD WINAPI InstanceThread(LPVOID lpvParam) {
	DWORD cbBytesReadReq = 0, cbBytesReadData = 0, cbReplyBytes = 0, cbWritten = 0;
	BOOL fSuccess = FALSE;
	TCHAR chRequest[BUFSIZE];
	TCHAR  chReply[BUFSIZE];
	HANDLE hPipe = (HANDLE)lpvParam;

	// Loop until done reading
	while (true) {
		ULONG PID;
		GetNamedPipeClientProcessId(hPipe, &PID);
		TCHAR filename[MAX_PATH];
		HANDLE processHandle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, PID);
		if (processHandle != NULL) {
			if (GetModuleFileNameEx(processHandle, NULL, filename, MAX_PATH) == 0) {
				//tcerr << "Failed to get module filename." << endl;
				return -1;
			} else {
				//tcout << "Module filename is: " << filename << endl;

			}
			CloseHandle(processHandle);
		} else {
			//tcerr << "Failed to open process." << endl;
			return -1;
		}
		// Read client requests from the pipe. This simplistic code only allows messages
		// up to BUFSIZE characters in length.
		fSuccess = ReadFile(
			hPipe,        // handle to pipe 
			chReply,    // buffer to receive data 
			BUFSIZE * sizeof(TCHAR), // size of buffer 
			&cbBytesReadReq, // number of bytes read 
			NULL);        // not overlapped I/O 

		if (!fSuccess || cbBytesReadReq == 0) {
			if (GetLastError() == ERROR_BROKEN_PIPE) {
				//_tprintf(TEXT("InstanceThread: client disconnected.\n"));
			} else {
				//_tprintf(TEXT("InstanceThread ReadFile failed, GLE=%d.\n"), GetLastError());
			}
			const wchar_t* message = L"disconnected1";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			break;
		}

		//mbstowcs(chRequest, (char*)chReply, BUFSIZE * sizeof(TCHAR));
		MultiByteToWideChar(CP_UTF8, 0, (LPCCH)chReply, -1, chRequest, BUFSIZE);
		
		bool ansResult;

		if (wcsncmp(chRequest, L"SCAN", 4) == 0) {
			ansResult = ProcessScan(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"REMV", 4) == 0) {
			ansResult = ProcessRemove(hPipe, chRequest, &cbReplyBytes);
		}

		if (wcsncmp(chRequest, L"QUAR", 4) == 0) {
			ansResult = ProcessQuarantine(hPipe, chRequest, &cbReplyBytes);
		}

		if (!ansResult) {
			//_tprintf(TEXT("InstanceThread WriteFile failed, GLE=%d.\n"), GetLastError());
			//const wchar_t* message = L"disconnected2";
			//ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
			break;
		}
	}

	const wchar_t* message = L"disconnected";
	ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

	FlushFileBuffers(hPipe);
	DisconnectNamedPipe(hPipe);
	CloseHandle(hPipe);

	//printf("InstanceThread exiting.\n");
	return 1;
}

DWORD ProtectProcess(void) {
	HANDLE hProcess = GetCurrentProcess();
	PACL pEmptyDacl;
	DWORD dwErr;

	// using malloc guarantees proper alignment
	pEmptyDacl = (PACL)malloc(sizeof(ACL));

	if (!InitializeAcl(pEmptyDacl, sizeof(ACL), ACL_REVISION)) {
		dwErr = GetLastError();
	} else {
		dwErr = SetSecurityInfo(hProcess, SE_KERNEL_OBJECT,
			DACL_SECURITY_INFORMATION, NULL, NULL, pEmptyDacl, NULL);
	}

	free(pEmptyDacl);
	return dwErr;
}

DWORD WINAPI WatchdogThread(LPVOID lpvParam) {
	HANDLE hProcess;
	TCHAR szFile[MAX_PATH];
	GetModuleFileName(NULL, szFile, MAX_PATH);
	PathRemoveFileSpec(szFile);
	wcscat(szFile, L"\\Watchdog.exe");

	while (true) {
		return 0;
		hProcess = GetModuleHandleA(szFile);

		//HANDLE hProcess = OpenProcess(SYNCHRONIZE, false, pid);
		//if (hProcess == 0) {
			//MessageBoxA(NULL, "process handle zero", "Watchdog:", 0);
			//Sleep(1000);
			//continue;
		//}

		//MessageBoxA(NULL, "starting wait", "Watchdog:", 0);
		//WaitForSingleObject(hProcess, INFINITE);
		//MessageBoxA(NULL, "restarting service", "Watchdog:", 0);
	}
}

VOID ReportSvcStatus(DWORD dwCurrentState,
	DWORD dwWin32ExitCode,
	DWORD dwWaitHint) {
	static DWORD dwCheckPoint = 1;

	gSvcStatus.dwCurrentState = dwCurrentState;
	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
	gSvcStatus.dwWaitHint = dwWaitHint;

	if (dwCurrentState == SERVICE_START_PENDING)
		gSvcStatus.dwControlsAccepted = 0;
	//else gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

	if ((dwCurrentState == SERVICE_RUNNING) ||
		(dwCurrentState == SERVICE_STOPPED))
		gSvcStatus.dwCheckPoint = 0;
	else gSvcStatus.dwCheckPoint = dwCheckPoint++;

	// Report the status of the service to the SCM.
	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);
}

VOID SvcInit(DWORD dwArgc, LPTSTR * lpszArgv) {

	ghSvcStopEvent = CreateEvent(
		NULL,    // default security attributes
		TRUE,    // manual reset event
		FALSE,   // not signaled
		NULL);   // no name

	if (ghSvcStopEvent == NULL) {
		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}

	// Report running status when initialization is complete.

	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);

	// TO_DO: Perform work until service stops.

	while (1) {
		// Check whether to stop the service.

		WaitForSingleObject(ghSvcStopEvent, INFINITE);

		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
		return;
	}
}

VOID WINAPI SvcCtrlHandler(DWORD dwCtrl) {
	// Handle the requested control code. 

	switch (dwCtrl) {
	case SERVICE_CONTROL_STOP:
		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

		// Signal the service to stop.

		SetEvent(ghSvcStopEvent);
		ReportSvcStatus(gSvcStatus.dwCurrentState, NO_ERROR, 0);

		return;

	case SERVICE_CONTROL_INTERROGATE:
		break;

	default:
		break;
	}

}

DWORD WINAPI WaitConnect(LPVOID lpParameter) {
	HANDLE pipe;
	DWORD dwThreadId;


	while (true) {
		pipe = CreateNamedPipe(L"\\\\.\\pipe\\MTUCI_Antimalware_pipe", PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 512, 512, 5000, NULL);
		if (pipe == INVALID_HANDLE_VALUE) {
			return -1;
		}
		bool fConnected = ConnectNamedPipe(pipe, NULL) ? TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
		if (fConnected) {

			const wchar_t* message = L"connected";
			ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);

			// Create a thread for this client. 
			HANDLE hThread = CreateThread(
				NULL,              // no security attribute 
				0,                 // default stack size 
				InstanceThread,    // thread proc
				(LPVOID)pipe,      // thread parameter 
				0,                 // not suspended 
				&dwThreadId);      // returns thread ID 

			if (hThread == NULL) {
				const wchar_t* message = L"exit1";
				ReportEvent(event_log, EVENTLOG_SUCCESS, 0, 0, NULL, 1, 0, &message, NULL);
				//_tprintf(TEXT("CreateThread failed, GLE=%d.\n"), GetLastError());
				return -1;
			} else {
				CloseHandle(hThread);
			}
		} else {

			// The client could not connect, so close the pipe. 
			CloseHandle(pipe);
		}
	}
	return 0;
}

VOID WINAPI SvcMain(DWORD dwArgc, LPTSTR * lpszArgv) {
	// Register the handler function for the service

	gSvcStatusHandle = RegisterServiceCtrlHandler(
		SVCNAME,
		SvcCtrlHandler);

	if (!gSvcStatusHandle) {
		//SvcReportEvent(TEXT("RegisterServiceCtrlHandler"));
		return;
	}

	// These SERVICE_STATUS members remain as set here

	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
	gSvcStatus.dwServiceSpecificExitCode = 0;

	// Report initial status to the SCM

	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

	// Perform service-specific initialization and work.

	DWORD waitConnectThreadID;
	HANDLE hWaitConnectThread;
	base = parseBase();

	event_log = RegisterEventSource(NULL, SVCNAME);
	ProtectProcess();

	hWaitConnectThread = CreateThread(NULL, 0, &WaitConnect, (LPVOID)1, 0, &waitConnectThreadID);

	SvcInit(dwArgc, lpszArgv);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;
	int iResult;

	if (wcscmp(lpCmdLine, L"") == 0) {
		SERVICE_TABLE_ENTRY DispatchTable[] =
		{
			{ (LPWSTR)SVCNAME, (LPSERVICE_MAIN_FUNCTION)SvcMain },
			{ NULL, NULL }
		};

		// This call returns when the service has stopped. 
		// The process should simply terminate when the call returns.

		if (!StartServiceCtrlDispatcher(DispatchTable)) {
			//SvcReportEvent(TEXT("StartServiceCtrlDispatcher"));
		}
	} else if (wcscmp(lpCmdLine, L"install") == 0) {
		installService();
	} else if (wcscmp(lpCmdLine, L"uninstall") == 0) {
		uninstallService();
	} else if (wcscmp(lpCmdLine, L"run") == 0) {
		runService();
	}

	DWORD threadID;
	//HANDLE hServiceThread = CreateThread(NULL, 0, &clientThread, 0, 0, &threadID);

	return 0;
}
