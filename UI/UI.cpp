#pragma warning (disable : 4996)

#define WIN32_LEAN_AND_MEAN
// Файлы заголовков Windows
#include <windows.h>
#include <string>
#include <shellapi.h>

#pragma comment(lib, "Ws2_32.lib")

// Глобальные переменные:
HINSTANCE hInst; // текущий экземпляр
const wchar_t* szTitle = L"Antimalware UI"; // Текст строки заголовка
const wchar_t* szWindowClass = L"Antimalware UI"; // имя класса главного окна
static HWND hwndStart;
static HWND hwndStop;
HANDLE hPipe;

// Отправить объявления функций, включенных в этот модуль кода:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);

HWND CreateElement(LPCSTR c, LPCSTR w, DWORD s, HWND h, HMENU m) {
	return CreateWindowExA(0, c, w, s, 0, 0, 0, 0, h, m, (HINSTANCE)GetWindowLongPtr(h, -6), 0);
}

void Send(std::string str) {
	for (char i = 0; i < 2; i++) {
		if (hPipe == INVALID_HANDLE_VALUE) {
			hPipe = CreateFileA("\\\\.\\pipe\\MTUCI_Antimalware_pipe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
			if (hPipe == INVALID_HANDLE_VALUE) {
				MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), ("error sending " + str + " request").c_str(), 0);
				return;
			}
		}
		DWORD cbWritten;
		bool writed = WriteFile(hPipe, str.c_str(), strlen(str.c_str()) + 1, &cbWritten, NULL);
		if (!writed) {
			CloseHandle(hPipe);
			hPipe = INVALID_HANDLE_VALUE;
			continue;
		}
		break;
	}
	MessageBoxA(NULL, ("sent " + str + " request").c_str(), "Information", 0);
}

int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
	_In_opt_ HINSTANCE hPrevInstance,
	_In_ LPWSTR    lpCmdLine,
	_In_ int       nCmdShow) {
	MSG msg;

	// Инициализация глобальных строк
	MyRegisterClass(hInstance);

	// Выполнить инициализацию приложения:
	if (!InitInstance(hInstance, nCmdShow)) {
		return FALSE;
	}

	// Цикл основного сообщения:
	while (GetMessage(&msg, nullptr, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return (int)msg.wParam;
}



//
//  ФУНКЦИЯ: MyRegisterClass()
//
//  ЦЕЛЬ: Регистрирует класс окна.
//
ATOM MyRegisterClass(HINSTANCE hInstance) {
	WNDCLASSEXW wcex;

	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = 0;
	wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = 0;
	wcex.lpszClassName = szWindowClass;
	wcex.hIconSm = 0;

	return RegisterClassExW(&wcex);
}

//
//   ФУНКЦИЯ: InitInstance(HINSTANCE, int)
//
//   ЦЕЛЬ: Сохраняет маркер экземпляра и создает главное окно
//
//   КОММЕНТАРИИ:
//
//        В этой функции маркер экземпляра сохраняется в глобальной переменной, а также
//        создается и выводится главное окно программы.
//
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) {
	hInst = hInstance; // Сохранить маркер экземпляра в глобальной переменной

	HWND hWnd = CreateWindowExW(0, szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
		0, 0, 450, 130, nullptr, nullptr, hInstance, nullptr);

	if (!hWnd) {
		return FALSE;
	}

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);

	return TRUE;
}

//
//  ФУНКЦИЯ: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  ЦЕЛЬ: Обрабатывает сообщения в главном окне.
//
//  WM_COMMAND  - обработать меню приложения
//  WM_PAINT    - Отрисовка главного окна
//  WM_DESTROY  - отправить сообщение о выходе и вернуться
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
	switch (message) {
	case WM_CREATE:
	{
		hwndStart = CreateElement("BUTTON", "Start service", WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, hWnd, (HMENU)1);
		hwndStop = CreateElement("BUTTON", "Stop service", WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_PUSHBUTTON, hWnd, (HMENU)2);
	}
	break;
	case WM_PAINT:
	{
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hWnd, &ps);
		// TODO: Добавьте сюда любой код прорисовки, использующий HDC...
		EndPaint(hWnd, &ps);
	}
	break;
	case WM_SIZE:
	{
		WORD w = LOWORD(lParam);
		WORD h = HIWORD(lParam);
		MoveWindow(hwndStart, 60, 30, 150, 30, TRUE);
		MoveWindow(hwndStop, 220, 30, 150, 30, TRUE);
	}
		return 0;
	case WM_GETMINMAXINFO:
	{
		LPMINMAXINFO lpMMI = (LPMINMAXINFO)lParam;
		lpMMI->ptMinTrackSize.x = 230;
		lpMMI->ptMinTrackSize.y = 40;
	}
	case WM_COMMAND:
	{
		int id = LOWORD(wParam);
		switch (id) {
		case 1:
		{
			SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
			SC_HANDLE hService = OpenService(hSCManager, L"MTUCI_AntimalwareService", SERVICE_START);

			if (!StartService(hService, 0, NULL)) {
				CloseServiceHandle(hSCManager);
				MessageBoxA(NULL, std::to_string(GetLastError()).c_str(), "error starting service", 0);
				return -1;
			}

			CloseServiceHandle(hService);
			CloseServiceHandle(hSCManager);
			MessageBoxA(NULL, "started successfully", "Info", 0);
		}
			break;
		case 2:
			Send("stop");
			break;
		}
		break;
	}
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}
	return 0;
}
